// ignore_for_file: always_specify_types
// ignore_for_file: camel_case_types
// ignore_for_file: non_constant_identifier_names

// AUTO GENERATED FILE, DO NOT EDIT.
//
// Generated by `package:ffigen`.
// ignore_for_file: type=lint
import 'dart:ffi' as ffi;

/// Realm native lib bindings.
class RealmLibrary {
  /// Holds the symbol lookup function.
  final ffi.Pointer<T> Function<T extends ffi.NativeType>(String symbolName)
      _lookup;

  /// The symbols are looked up in [dynamicLibrary].
  RealmLibrary(ffi.DynamicLibrary dynamicLibrary)
      : _lookup = dynamicLibrary.lookup;

  /// The symbols are looked up with [lookup].
  RealmLibrary.fromLookup(
      ffi.Pointer<T> Function<T extends ffi.NativeType>(String symbolName)
          lookup)
      : _lookup = lookup;

  /// Add a callback that will be invoked every time the view of this file is updated.
  ///
  /// This callback is guaranteed to be invoked before any object or collection change
  /// notifications for this realm are delivered.
  ///
  /// @return a registration token used to remove the callback.
  ffi.Pointer<realm_callback_token_t> realm_add_realm_changed_callback(
    ffi.Pointer<realm_t> arg0,
    realm_on_realm_change_func_t arg1,
    ffi.Pointer<ffi.Void> userdata,
    realm_free_userdata_func_t userdata_free,
  ) {
    return _realm_add_realm_changed_callback(
      arg0,
      arg1,
      userdata,
      userdata_free,
    );
  }

  late final _realm_add_realm_changed_callbackPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<realm_callback_token_t> Function(
              ffi.Pointer<realm_t>,
              realm_on_realm_change_func_t,
              ffi.Pointer<ffi.Void>,
              realm_free_userdata_func_t)>>('realm_add_realm_changed_callback');
  late final _realm_add_realm_changed_callback =
      _realm_add_realm_changed_callbackPtr.asFunction<
          ffi.Pointer<realm_callback_token_t> Function(
              ffi.Pointer<realm_t>,
              realm_on_realm_change_func_t,
              ffi.Pointer<ffi.Void>,
              realm_free_userdata_func_t)>();

  /// Add a callback that will be invoked the first time that the given realm is refreshed to the version which is the
  /// latest version at the time when this is called.
  /// @return a refresh token to remove the callback
  ffi.Pointer<realm_refresh_callback_token_t> realm_add_realm_refresh_callback(
    ffi.Pointer<realm_t> arg0,
    realm_on_realm_refresh_func_t arg1,
    ffi.Pointer<ffi.Void> userdata,
    realm_free_userdata_func_t userdata_free,
  ) {
    return _realm_add_realm_refresh_callback(
      arg0,
      arg1,
      userdata,
      userdata_free,
    );
  }

  late final _realm_add_realm_refresh_callbackPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<realm_refresh_callback_token_t> Function(
              ffi.Pointer<realm_t>,
              realm_on_realm_refresh_func_t,
              ffi.Pointer<ffi.Void>,
              realm_free_userdata_func_t)>>('realm_add_realm_refresh_callback');
  late final _realm_add_realm_refresh_callback =
      _realm_add_realm_refresh_callbackPtr.asFunction<
          ffi.Pointer<realm_refresh_callback_token_t> Function(
              ffi.Pointer<realm_t>,
              realm_on_realm_refresh_func_t,
              ffi.Pointer<ffi.Void>,
              realm_free_userdata_func_t)>();

  /// Add a callback that will be invoked every time the schema of this realm is changed.
  ///
  /// @return a registration token used to remove the callback.
  ffi.Pointer<realm_callback_token_t> realm_add_schema_changed_callback(
    ffi.Pointer<realm_t> arg0,
    realm_on_schema_change_func_t arg1,
    ffi.Pointer<ffi.Void> userdata,
    realm_free_userdata_func_t userdata_free,
  ) {
    return _realm_add_schema_changed_callback(
      arg0,
      arg1,
      userdata,
      userdata_free,
    );
  }

  late final _realm_add_schema_changed_callbackPtr = _lookup<
          ffi.NativeFunction<
              ffi.Pointer<realm_callback_token_t> Function(
                  ffi.Pointer<realm_t>,
                  realm_on_schema_change_func_t,
                  ffi.Pointer<ffi.Void>,
                  realm_free_userdata_func_t)>>(
      'realm_add_schema_changed_callback');
  late final _realm_add_schema_changed_callback =
      _realm_add_schema_changed_callbackPtr.asFunction<
          ffi.Pointer<realm_callback_token_t> Function(
              ffi.Pointer<realm_t>,
              realm_on_schema_change_func_t,
              ffi.Pointer<ffi.Void>,
              realm_free_userdata_func_t)>();

  /// start a new write transaction asynchronously for the realm passed as argument.
  bool realm_async_begin_write(
    ffi.Pointer<realm_t> realm,
    realm_async_begin_write_func_t arg1,
    ffi.Pointer<ffi.Void> userdata,
    realm_free_userdata_func_t userdata_free,
    bool notify_only,
    ffi.Pointer<ffi.UnsignedInt> transaction_id,
  ) {
    return _realm_async_begin_write(
      realm,
      arg1,
      userdata,
      userdata_free,
      notify_only,
      transaction_id,
    );
  }

  late final _realm_async_begin_writePtr = _lookup<
      ffi.NativeFunction<
          ffi.Bool Function(
              ffi.Pointer<realm_t>,
              realm_async_begin_write_func_t,
              ffi.Pointer<ffi.Void>,
              realm_free_userdata_func_t,
              ffi.Bool,
              ffi.Pointer<ffi.UnsignedInt>)>>('realm_async_begin_write');
  late final _realm_async_begin_write = _realm_async_begin_writePtr.asFunction<
      bool Function(
          ffi.Pointer<realm_t>,
          realm_async_begin_write_func_t,
          ffi.Pointer<ffi.Void>,
          realm_free_userdata_func_t,
          bool,
          ffi.Pointer<ffi.UnsignedInt>)>();

  /// Cancel the transaction referenced by the token passed as argument and set the optional boolean flag in order to
  /// inform the caller if the transaction was cancelled.
  bool realm_async_cancel(
    ffi.Pointer<realm_t> realm,
    int token,
    ffi.Pointer<ffi.Bool> cancelled,
  ) {
    return _realm_async_cancel(
      realm,
      token,
      cancelled,
    );
  }

  late final _realm_async_cancelPtr = _lookup<
      ffi.NativeFunction<
          ffi.Bool Function(ffi.Pointer<realm_t>, ffi.UnsignedInt,
              ffi.Pointer<ffi.Bool>)>>('realm_async_cancel');
  late final _realm_async_cancel = _realm_async_cancelPtr.asFunction<
      bool Function(ffi.Pointer<realm_t>, int, ffi.Pointer<ffi.Bool>)>();

  /// commit a transaction asynchronously for the realm passed as argument.
  bool realm_async_commit(
    ffi.Pointer<realm_t> realm,
    realm_async_commit_func_t arg1,
    ffi.Pointer<ffi.Void> userdata,
    realm_free_userdata_func_t userdata_free,
    bool allow_grouping,
    ffi.Pointer<ffi.UnsignedInt> transaction_id,
  ) {
    return _realm_async_commit(
      realm,
      arg1,
      userdata,
      userdata_free,
      allow_grouping,
      transaction_id,
    );
  }

  late final _realm_async_commitPtr = _lookup<
      ffi.NativeFunction<
          ffi.Bool Function(
              ffi.Pointer<realm_t>,
              realm_async_commit_func_t,
              ffi.Pointer<ffi.Void>,
              realm_free_userdata_func_t,
              ffi.Bool,
              ffi.Pointer<ffi.UnsignedInt>)>>('realm_async_commit');
  late final _realm_async_commit = _realm_async_commitPtr.asFunction<
      bool Function(
          ffi.Pointer<realm_t>,
          realm_async_commit_func_t,
          ffi.Pointer<ffi.Void>,
          realm_free_userdata_func_t,
          bool,
          ffi.Pointer<ffi.UnsignedInt>)>();

  /// for debugging only. Enable in realm_dart.cpp
  /// RLM_API void realm_dart_gc();
  ffi.Pointer<ffi.Void> realm_attach_finalizer(
    Object handle,
    ffi.Pointer<ffi.Void> realmPtr,
    int size,
  ) {
    return _realm_attach_finalizer(
      handle,
      realmPtr,
      size,
    );
  }

  late final _realm_attach_finalizerPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(ffi.Handle, ffi.Pointer<ffi.Void>,
              ffi.Int)>>('realm_attach_finalizer');
  late final _realm_attach_finalizer = _realm_attach_finalizerPtr.asFunction<
      ffi.Pointer<ffi.Void> Function(Object, ffi.Pointer<ffi.Void>, int)>();

  /// Begin a read transaction for the Realm file.
  ///
  /// @return True if no exception occurred.
  bool realm_begin_read(
    ffi.Pointer<realm_t> arg0,
  ) {
    return _realm_begin_read(
      arg0,
    );
  }

  late final _realm_begin_readPtr =
      _lookup<ffi.NativeFunction<ffi.Bool Function(ffi.Pointer<realm_t>)>>(
          'realm_begin_read');
  late final _realm_begin_read =
      _realm_begin_readPtr.asFunction<bool Function(ffi.Pointer<realm_t>)>();

  /// Begin a write transaction for the Realm file.
  ///
  /// @return True if no exception occurred.
  bool realm_begin_write(
    ffi.Pointer<realm_t> arg0,
  ) {
    return _realm_begin_write(
      arg0,
    );
  }

  late final _realm_begin_writePtr =
      _lookup<ffi.NativeFunction<ffi.Bool Function(ffi.Pointer<realm_t>)>>(
          'realm_begin_write');
  late final _realm_begin_write =
      _realm_begin_writePtr.asFunction<bool Function(ffi.Pointer<realm_t>)>();

  /// Clear the last error on the calling thread.
  ///
  /// Use this if the system has recovered from an error, e.g. by closing the
  /// offending Realm and reopening it, freeing up resources, or similar.
  ///
  /// @return True if an error was cleared.
  bool realm_clear_last_error() {
    return _realm_clear_last_error();
  }

  late final _realm_clear_last_errorPtr =
      _lookup<ffi.NativeFunction<ffi.Bool Function()>>(
          'realm_clear_last_error');
  late final _realm_clear_last_error =
      _realm_clear_last_errorPtr.asFunction<bool Function()>();

  /// Clone a Realm C Wrapper object.
  ///
  /// If the object is not clonable, this function fails with RLM_ERR_NOT_CLONABLE.
  ///
  /// @return A pointer to an object of the same type as the input, or NULL if
  /// cloning failed.
  ffi.Pointer<ffi.Void> realm_clone(
    ffi.Pointer<ffi.Void> arg0,
  ) {
    return _realm_clone(
      arg0,
    );
  }

  late final _realm_clonePtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>)>>('realm_clone');
  late final _realm_clone = _realm_clonePtr
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// Forcibly close a Realm file.
  ///
  /// Note that this invalidates all Realm instances for the same path.
  ///
  /// The Realm will be automatically closed when the last reference is released,
  /// including references to objects within the Realm.
  ///
  /// @return True if no exception occurred.
  bool realm_close(
    ffi.Pointer<realm_t> arg0,
  ) {
    return _realm_close(
      arg0,
    );
  }

  late final _realm_closePtr =
      _lookup<ffi.NativeFunction<ffi.Bool Function(ffi.Pointer<realm_t>)>>(
          'realm_close');
  late final _realm_close =
      _realm_closePtr.asFunction<bool Function(ffi.Pointer<realm_t>)>();

  /// Get the indices of changes in a collection notification.
  ///
  /// Note: For moves, every `from` index will also be present among deletions, and
  /// every `to` index will also be present among insertions.
  ///
  /// This function cannot fail.
  ///
  /// @param out_deletion_indices Where to put the indices of deleted elements
  /// (*before* the deletion happened). May be NULL.
  /// @param max_deletion_indices The max number of indices to write to @a
  /// out_deletion_indices.
  /// @param out_insertion_indices Where the put the indices of inserted elements
  /// (*after* the insertion happened). May be NULL.
  /// @param max_insertion_indices The max number of indices to write to @a
  /// out_insertion_indices.
  /// @param out_modification_indices Where to put the indices of modified elements
  /// (*before* any insertions or deletions of
  /// other elements). May be NULL.
  /// @param max_modification_indices The max number of indices to write to @a
  /// out_modification_indices.
  /// @param out_modification_indices_after Where to put the indices of modified
  /// elements (*after* any insertions or
  /// deletions of other elements). May be
  /// NULL.
  /// @param max_modification_indices_after The max number of indices to write to
  /// @a out_modification_indices_after.
  /// @param out_moves Where to put the pairs of indices of moved elements. May be
  /// NULL.
  /// @param max_moves The max number of pairs to write to @a out_moves.
  void realm_collection_changes_get_changes(
    ffi.Pointer<realm_collection_changes_t> arg0,
    ffi.Pointer<ffi.Size> out_deletion_indices,
    int max_deletion_indices,
    ffi.Pointer<ffi.Size> out_insertion_indices,
    int max_insertion_indices,
    ffi.Pointer<ffi.Size> out_modification_indices,
    int max_modification_indices,
    ffi.Pointer<ffi.Size> out_modification_indices_after,
    int max_modification_indices_after,
    ffi.Pointer<realm_collection_move_t> out_moves,
    int max_moves,
  ) {
    return _realm_collection_changes_get_changes(
      arg0,
      out_deletion_indices,
      max_deletion_indices,
      out_insertion_indices,
      max_insertion_indices,
      out_modification_indices,
      max_modification_indices,
      out_modification_indices_after,
      max_modification_indices_after,
      out_moves,
      max_moves,
    );
  }

  late final _realm_collection_changes_get_changesPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<realm_collection_changes_t>,
              ffi.Pointer<ffi.Size>,
              ffi.Size,
              ffi.Pointer<ffi.Size>,
              ffi.Size,
              ffi.Pointer<ffi.Size>,
              ffi.Size,
              ffi.Pointer<ffi.Size>,
              ffi.Size,
              ffi.Pointer<realm_collection_move_t>,
              ffi.Size)>>('realm_collection_changes_get_changes');
  late final _realm_collection_changes_get_changes =
      _realm_collection_changes_get_changesPtr.asFunction<
          void Function(
              ffi.Pointer<realm_collection_changes_t>,
              ffi.Pointer<ffi.Size>,
              int,
              ffi.Pointer<ffi.Size>,
              int,
              ffi.Pointer<ffi.Size>,
              int,
              ffi.Pointer<ffi.Size>,
              int,
              ffi.Pointer<realm_collection_move_t>,
              int)>();

  /// Get the number of various types of changes in a collection notification.
  ///
  /// @param out_num_deletions The number of deletions. May be NULL.
  /// @param out_num_insertions The number of insertions. May be NULL.
  /// @param out_num_modifications The number of modifications. May be NULL.
  /// @param out_num_moves The number of moved elements. May be NULL.
  /// @param out_collection_was_cleared a flag to signal if the collection has been cleared. May be NULL
  /// @param out_collection_was_deleted a flag to signal if the collection has been deleted. May be NULL
  void realm_collection_changes_get_num_changes(
    ffi.Pointer<realm_collection_changes_t> arg0,
    ffi.Pointer<ffi.Size> out_num_deletions,
    ffi.Pointer<ffi.Size> out_num_insertions,
    ffi.Pointer<ffi.Size> out_num_modifications,
    ffi.Pointer<ffi.Size> out_num_moves,
    ffi.Pointer<ffi.Bool> out_collection_was_cleared,
    ffi.Pointer<ffi.Bool> out_collection_was_deleted,
  ) {
    return _realm_collection_changes_get_num_changes(
      arg0,
      out_num_deletions,
      out_num_insertions,
      out_num_modifications,
      out_num_moves,
      out_collection_was_cleared,
      out_collection_was_deleted,
    );
  }

  late final _realm_collection_changes_get_num_changesPtr = _lookup<
          ffi.NativeFunction<
              ffi.Void Function(
                  ffi.Pointer<realm_collection_changes_t>,
                  ffi.Pointer<ffi.Size>,
                  ffi.Pointer<ffi.Size>,
                  ffi.Pointer<ffi.Size>,
                  ffi.Pointer<ffi.Size>,
                  ffi.Pointer<ffi.Bool>,
                  ffi.Pointer<ffi.Bool>)>>(
      'realm_collection_changes_get_num_changes');
  late final _realm_collection_changes_get_num_changes =
      _realm_collection_changes_get_num_changesPtr.asFunction<
          void Function(
              ffi.Pointer<realm_collection_changes_t>,
              ffi.Pointer<ffi.Size>,
              ffi.Pointer<ffi.Size>,
              ffi.Pointer<ffi.Size>,
              ffi.Pointer<ffi.Size>,
              ffi.Pointer<ffi.Bool>,
              ffi.Pointer<ffi.Bool>)>();

  /// Get the number of various types of changes in a collection notification,
  /// suitable for acquiring the change indices as ranges, which is much more
  /// compact in memory than getting the individual indices when multiple adjacent
  /// elements have been modified.
  ///
  /// @param out_num_deletion_ranges The number of deleted ranges. May be NULL.
  /// @param out_num_insertion_ranges The number of inserted ranges. May be NULL.
  /// @param out_num_modification_ranges The number of modified ranges. May be
  /// NULL.
  /// @param out_num_moves The number of moved elements. May be NULL.
  void realm_collection_changes_get_num_ranges(
    ffi.Pointer<realm_collection_changes_t> arg0,
    ffi.Pointer<ffi.Size> out_num_deletion_ranges,
    ffi.Pointer<ffi.Size> out_num_insertion_ranges,
    ffi.Pointer<ffi.Size> out_num_modification_ranges,
    ffi.Pointer<ffi.Size> out_num_moves,
  ) {
    return _realm_collection_changes_get_num_ranges(
      arg0,
      out_num_deletion_ranges,
      out_num_insertion_ranges,
      out_num_modification_ranges,
      out_num_moves,
    );
  }

  late final _realm_collection_changes_get_num_rangesPtr = _lookup<
          ffi.NativeFunction<
              ffi.Void Function(
                  ffi.Pointer<realm_collection_changes_t>,
                  ffi.Pointer<ffi.Size>,
                  ffi.Pointer<ffi.Size>,
                  ffi.Pointer<ffi.Size>,
                  ffi.Pointer<ffi.Size>)>>(
      'realm_collection_changes_get_num_ranges');
  late final _realm_collection_changes_get_num_ranges =
      _realm_collection_changes_get_num_rangesPtr.asFunction<
          void Function(
              ffi.Pointer<realm_collection_changes_t>,
              ffi.Pointer<ffi.Size>,
              ffi.Pointer<ffi.Size>,
              ffi.Pointer<ffi.Size>,
              ffi.Pointer<ffi.Size>)>();

  void realm_collection_changes_get_ranges(
    ffi.Pointer<realm_collection_changes_t> arg0,
    ffi.Pointer<realm_index_range_t> out_deletion_ranges,
    int max_deletion_ranges,
    ffi.Pointer<realm_index_range_t> out_insertion_ranges,
    int max_insertion_ranges,
    ffi.Pointer<realm_index_range_t> out_modification_ranges,
    int max_modification_ranges,
    ffi.Pointer<realm_index_range_t> out_modification_ranges_after,
    int max_modification_ranges_after,
    ffi.Pointer<realm_collection_move_t> out_moves,
    int max_moves,
  ) {
    return _realm_collection_changes_get_ranges(
      arg0,
      out_deletion_ranges,
      max_deletion_ranges,
      out_insertion_ranges,
      max_insertion_ranges,
      out_modification_ranges,
      max_modification_ranges,
      out_modification_ranges_after,
      max_modification_ranges_after,
      out_moves,
      max_moves,
    );
  }

  late final _realm_collection_changes_get_rangesPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<realm_collection_changes_t>,
              ffi.Pointer<realm_index_range_t>,
              ffi.Size,
              ffi.Pointer<realm_index_range_t>,
              ffi.Size,
              ffi.Pointer<realm_index_range_t>,
              ffi.Size,
              ffi.Pointer<realm_index_range_t>,
              ffi.Size,
              ffi.Pointer<realm_collection_move_t>,
              ffi.Size)>>('realm_collection_changes_get_ranges');
  late final _realm_collection_changes_get_ranges =
      _realm_collection_changes_get_rangesPtr.asFunction<
          void Function(
              ffi.Pointer<realm_collection_changes_t>,
              ffi.Pointer<realm_index_range_t>,
              int,
              ffi.Pointer<realm_index_range_t>,
              int,
              ffi.Pointer<realm_index_range_t>,
              int,
              ffi.Pointer<realm_index_range_t>,
              int,
              ffi.Pointer<realm_collection_move_t>,
              int)>();

  /// Commit a write transaction.
  ///
  /// @return True if the commit succeeded and no exceptions were thrown.
  bool realm_commit(
    ffi.Pointer<realm_t> arg0,
  ) {
    return _realm_commit(
      arg0,
    );
  }

  late final _realm_commitPtr =
      _lookup<ffi.NativeFunction<ffi.Bool Function(ffi.Pointer<realm_t>)>>(
          'realm_commit');
  late final _realm_commit =
      _realm_commitPtr.asFunction<bool Function(ffi.Pointer<realm_t>)>();

  /// Vacuum the free space from the realm file, reducing its file size.
  ///
  /// @return True if no exceptions are thrown, false otherwise.
  bool realm_compact(
    ffi.Pointer<realm_t> arg0,
    ffi.Pointer<ffi.Bool> did_compact,
  ) {
    return _realm_compact(
      arg0,
      did_compact,
    );
  }

  late final _realm_compactPtr = _lookup<
      ffi.NativeFunction<
          ffi.Bool Function(
              ffi.Pointer<realm_t>, ffi.Pointer<ffi.Bool>)>>('realm_compact');
  late final _realm_compact = _realm_compactPtr
      .asFunction<bool Function(ffi.Pointer<realm_t>, ffi.Pointer<ffi.Bool>)>();

  /// True if automatic change notifications should be generated.
  ///
  /// This function cannot fail.
  bool realm_config_get_automatic_change_notifications(
    ffi.Pointer<realm_config_t> arg0,
  ) {
    return _realm_config_get_automatic_change_notifications(
      arg0,
    );
  }

  late final _realm_config_get_automatic_change_notificationsPtr = _lookup<
          ffi.NativeFunction<ffi.Bool Function(ffi.Pointer<realm_config_t>)>>(
      'realm_config_get_automatic_change_notifications');
  late final _realm_config_get_automatic_change_notifications =
      _realm_config_get_automatic_change_notificationsPtr
          .asFunction<bool Function(ffi.Pointer<realm_config_t>)>();

  /// Check if realms are cached
  bool realm_config_get_cached(
    ffi.Pointer<realm_config_t> arg0,
  ) {
    return _realm_config_get_cached(
      arg0,
    );
  }

  late final _realm_config_get_cachedPtr = _lookup<
          ffi.NativeFunction<ffi.Bool Function(ffi.Pointer<realm_config_t>)>>(
      'realm_config_get_cached');
  late final _realm_config_get_cached = _realm_config_get_cachedPtr
      .asFunction<bool Function(ffi.Pointer<realm_config_t>)>();

  /// True if file format upgrades on open are disabled.
  ///
  /// This function cannot fail.
  bool realm_config_get_disable_format_upgrade(
    ffi.Pointer<realm_config_t> arg0,
  ) {
    return _realm_config_get_disable_format_upgrade(
      arg0,
    );
  }

  late final _realm_config_get_disable_format_upgradePtr = _lookup<
          ffi.NativeFunction<ffi.Bool Function(ffi.Pointer<realm_config_t>)>>(
      'realm_config_get_disable_format_upgrade');
  late final _realm_config_get_disable_format_upgrade =
      _realm_config_get_disable_format_upgradePtr
          .asFunction<bool Function(ffi.Pointer<realm_config_t>)>();

  /// Get the encryption key for the realm.
  ///
  /// The output buffer must be at least 64 bytes.
  ///
  /// @returns The length of the encryption key (0 or 64)
  int realm_config_get_encryption_key(
    ffi.Pointer<realm_config_t> arg0,
    ffi.Pointer<ffi.Uint8> out_key,
  ) {
    return _realm_config_get_encryption_key(
      arg0,
      out_key,
    );
  }

  late final _realm_config_get_encryption_keyPtr = _lookup<
      ffi.NativeFunction<
          ffi.Size Function(ffi.Pointer<realm_config_t>,
              ffi.Pointer<ffi.Uint8>)>>('realm_config_get_encryption_key');
  late final _realm_config_get_encryption_key =
      _realm_config_get_encryption_keyPtr.asFunction<
          int Function(ffi.Pointer<realm_config_t>, ffi.Pointer<ffi.Uint8>)>();

  /// Check realm FIFO path
  ffi.Pointer<ffi.Char> realm_config_get_fifo_path(
    ffi.Pointer<realm_config_t> arg0,
  ) {
    return _realm_config_get_fifo_path(
      arg0,
    );
  }

  late final _realm_config_get_fifo_pathPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<realm_config_t>)>>('realm_config_get_fifo_path');
  late final _realm_config_get_fifo_path =
      _realm_config_get_fifo_pathPtr.asFunction<
          ffi.Pointer<ffi.Char> Function(ffi.Pointer<realm_config_t>)>();

  /// Check if realm is configured in memory
  bool realm_config_get_in_memory(
    ffi.Pointer<realm_config_t> arg0,
  ) {
    return _realm_config_get_in_memory(
      arg0,
    );
  }

  late final _realm_config_get_in_memoryPtr = _lookup<
          ffi.NativeFunction<ffi.Bool Function(ffi.Pointer<realm_config_t>)>>(
      'realm_config_get_in_memory');
  late final _realm_config_get_in_memory = _realm_config_get_in_memoryPtr
      .asFunction<bool Function(ffi.Pointer<realm_config_t>)>();

  /// Get maximum number of active versions in the realm file allowed before an
  /// exception is thrown.
  ///
  /// This function cannot fail.
  int realm_config_get_max_number_of_active_versions(
    ffi.Pointer<realm_config_t> arg0,
  ) {
    return _realm_config_get_max_number_of_active_versions(
      arg0,
    );
  }

  late final _realm_config_get_max_number_of_active_versionsPtr = _lookup<
          ffi.NativeFunction<ffi.Uint64 Function(ffi.Pointer<realm_config_t>)>>(
      'realm_config_get_max_number_of_active_versions');
  late final _realm_config_get_max_number_of_active_versions =
      _realm_config_get_max_number_of_active_versionsPtr
          .asFunction<int Function(ffi.Pointer<realm_config_t>)>();

  /// Get the path of the realm being opened.
  ///
  /// This function cannot fail.
  ffi.Pointer<ffi.Char> realm_config_get_path(
    ffi.Pointer<realm_config_t> arg0,
  ) {
    return _realm_config_get_path(
      arg0,
    );
  }

  late final _realm_config_get_pathPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<realm_config_t>)>>('realm_config_get_path');
  late final _realm_config_get_path = _realm_config_get_pathPtr.asFunction<
      ffi.Pointer<ffi.Char> Function(ffi.Pointer<realm_config_t>)>();

  /// Get the schema for this realm.
  ///
  /// Note: The caller obtains ownership of the returned value, and must manually
  /// free it by calling `realm_release()`.
  ///
  /// @return A schema object, or NULL if the schema is not set (empty).
  ffi.Pointer<realm_schema_t> realm_config_get_schema(
    ffi.Pointer<realm_config_t> arg0,
  ) {
    return _realm_config_get_schema(
      arg0,
    );
  }

  late final _realm_config_get_schemaPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<realm_schema_t> Function(
              ffi.Pointer<realm_config_t>)>>('realm_config_get_schema');
  late final _realm_config_get_schema = _realm_config_get_schemaPtr.asFunction<
      ffi.Pointer<realm_schema_t> Function(ffi.Pointer<realm_config_t>)>();

  /// Get the schema mode.
  ///
  /// This function cannot fail.
  realm_schema_mode realm_config_get_schema_mode(
    ffi.Pointer<realm_config_t> arg0,
  ) {
    return realm_schema_mode.fromValue(_realm_config_get_schema_mode(
      arg0,
    ));
  }

  late final _realm_config_get_schema_modePtr = _lookup<
      ffi.NativeFunction<
          ffi.UnsignedInt Function(
              ffi.Pointer<realm_config_t>)>>('realm_config_get_schema_mode');
  late final _realm_config_get_schema_mode = _realm_config_get_schema_modePtr
      .asFunction<int Function(ffi.Pointer<realm_config_t>)>();

  /// Get the subset schema mode.
  ///
  /// This function cannot fail.
  realm_schema_subset_mode realm_config_get_schema_subset_mode(
    ffi.Pointer<realm_config_t> arg0,
  ) {
    return realm_schema_subset_mode
        .fromValue(_realm_config_get_schema_subset_mode(
      arg0,
    ));
  }

  late final _realm_config_get_schema_subset_modePtr = _lookup<
          ffi.NativeFunction<
              ffi.UnsignedInt Function(ffi.Pointer<realm_config_t>)>>(
      'realm_config_get_schema_subset_mode');
  late final _realm_config_get_schema_subset_mode =
      _realm_config_get_schema_subset_modePtr
          .asFunction<int Function(ffi.Pointer<realm_config_t>)>();

  /// Get the schema version of the schema.
  ///
  /// This function cannot fail.
  int realm_config_get_schema_version(
    ffi.Pointer<realm_config_t> arg0,
  ) {
    return _realm_config_get_schema_version(
      arg0,
    );
  }

  late final _realm_config_get_schema_versionPtr = _lookup<
          ffi.NativeFunction<ffi.Uint64 Function(ffi.Pointer<realm_config_t>)>>(
      'realm_config_get_schema_version');
  late final _realm_config_get_schema_version =
      _realm_config_get_schema_versionPtr
          .asFunction<int Function(ffi.Pointer<realm_config_t>)>();

  /// True if you can open the file without a file_format_upgrade
  bool realm_config_needs_file_format_upgrade(
    ffi.Pointer<realm_config_t> arg0,
  ) {
    return _realm_config_needs_file_format_upgrade(
      arg0,
    );
  }

  late final _realm_config_needs_file_format_upgradePtr = _lookup<
          ffi.NativeFunction<ffi.Bool Function(ffi.Pointer<realm_config_t>)>>(
      'realm_config_needs_file_format_upgrade');
  late final _realm_config_needs_file_format_upgrade =
      _realm_config_needs_file_format_upgradePtr
          .asFunction<bool Function(ffi.Pointer<realm_config_t>)>();

  /// Allocate a new configuration with default options.
  ffi.Pointer<realm_config_t> realm_config_new() {
    return _realm_config_new();
  }

  late final _realm_config_newPtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<realm_config_t> Function()>>(
          'realm_config_new');
  late final _realm_config_new =
      _realm_config_newPtr.asFunction<ffi.Pointer<realm_config_t> Function()>();

  /// Allow realm to manage automatically embedded objects when a migration from TopLevel to Embedded takes place.
  void realm_config_set_automatic_backlink_handling(
    ffi.Pointer<realm_config_t> arg0,
    bool arg1,
  ) {
    return _realm_config_set_automatic_backlink_handling(
      arg0,
      arg1,
    );
  }

  late final _realm_config_set_automatic_backlink_handlingPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<realm_config_t>,
              ffi.Bool)>>('realm_config_set_automatic_backlink_handling');
  late final _realm_config_set_automatic_backlink_handling =
      _realm_config_set_automatic_backlink_handlingPtr
          .asFunction<void Function(ffi.Pointer<realm_config_t>, bool)>();

  /// Automatically generated change notifications (default: true).
  ///
  /// This function cannot fail.
  void realm_config_set_automatic_change_notifications(
    ffi.Pointer<realm_config_t> arg0,
    bool arg1,
  ) {
    return _realm_config_set_automatic_change_notifications(
      arg0,
      arg1,
    );
  }

  late final _realm_config_set_automatic_change_notificationsPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<realm_config_t>,
              ffi.Bool)>>('realm_config_set_automatic_change_notifications');
  late final _realm_config_set_automatic_change_notifications =
      _realm_config_set_automatic_change_notificationsPtr
          .asFunction<void Function(ffi.Pointer<realm_config_t>, bool)>();

  /// If 'cached' is false, always return a new Realm instance.
  void realm_config_set_cached(
    ffi.Pointer<realm_config_t> arg0,
    bool cached,
  ) {
    return _realm_config_set_cached(
      arg0,
      cached,
    );
  }

  late final _realm_config_set_cachedPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<realm_config_t>,
              ffi.Bool)>>('realm_config_set_cached');
  late final _realm_config_set_cached = _realm_config_set_cachedPtr
      .asFunction<void Function(ffi.Pointer<realm_config_t>, bool)>();

  /// Set the data initialization function.
  ///
  /// The callback is invoked the first time the schema is created, such that the
  /// user can perform one-time initialization of the data in the realm.
  ///
  /// The realm instance passed to the callback is in a write transaction.
  ///
  /// This function cannot fail.
  void realm_config_set_data_initialization_function(
    ffi.Pointer<realm_config_t> arg0,
    realm_data_initialization_func_t arg1,
    ffi.Pointer<ffi.Void> userdata,
    realm_free_userdata_func_t userdata_free,
  ) {
    return _realm_config_set_data_initialization_function(
      arg0,
      arg1,
      userdata,
      userdata_free,
    );
  }

  late final _realm_config_set_data_initialization_functionPtr = _lookup<
          ffi.NativeFunction<
              ffi.Void Function(
                  ffi.Pointer<realm_config_t>,
                  realm_data_initialization_func_t,
                  ffi.Pointer<ffi.Void>,
                  realm_free_userdata_func_t)>>(
      'realm_config_set_data_initialization_function');
  late final _realm_config_set_data_initialization_function =
      _realm_config_set_data_initialization_functionPtr.asFunction<
          void Function(
              ffi.Pointer<realm_config_t>,
              realm_data_initialization_func_t,
              ffi.Pointer<ffi.Void>,
              realm_free_userdata_func_t)>();

  /// Disable file format upgrade on open (default: false).
  ///
  /// If a migration is needed to open the realm file with the provided schema, an
  /// error is thrown rather than automatically performing the migration.
  ///
  /// This function cannot fail.
  void realm_config_set_disable_format_upgrade(
    ffi.Pointer<realm_config_t> arg0,
    bool arg1,
  ) {
    return _realm_config_set_disable_format_upgrade(
      arg0,
      arg1,
    );
  }

  late final _realm_config_set_disable_format_upgradePtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<realm_config_t>,
              ffi.Bool)>>('realm_config_set_disable_format_upgrade');
  late final _realm_config_set_disable_format_upgrade =
      _realm_config_set_disable_format_upgradePtr
          .asFunction<void Function(ffi.Pointer<realm_config_t>, bool)>();

  /// Set the encryption key for the realm.
  ///
  /// The key must be either 64 bytes long or have length zero (in which case
  /// encryption is disabled).
  ///
  /// This function may fail if the encryption key has the wrong length.
  bool realm_config_set_encryption_key(
    ffi.Pointer<realm_config_t> arg0,
    ffi.Pointer<ffi.Uint8> key,
    int key_size,
  ) {
    return _realm_config_set_encryption_key(
      arg0,
      key,
      key_size,
    );
  }

  late final _realm_config_set_encryption_keyPtr = _lookup<
      ffi.NativeFunction<
          ffi.Bool Function(ffi.Pointer<realm_config_t>, ffi.Pointer<ffi.Uint8>,
              ffi.Size)>>('realm_config_set_encryption_key');
  late final _realm_config_set_encryption_key =
      _realm_config_set_encryption_keyPtr.asFunction<
          bool Function(
              ffi.Pointer<realm_config_t>, ffi.Pointer<ffi.Uint8>, int)>();

  /// Set FIFO path
  void realm_config_set_fifo_path(
    ffi.Pointer<realm_config_t> arg0,
    ffi.Pointer<ffi.Char> arg1,
  ) {
    return _realm_config_set_fifo_path(
      arg0,
      arg1,
    );
  }

  late final _realm_config_set_fifo_pathPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<realm_config_t>,
              ffi.Pointer<ffi.Char>)>>('realm_config_set_fifo_path');
  late final _realm_config_set_fifo_path =
      _realm_config_set_fifo_pathPtr.asFunction<
          void Function(ffi.Pointer<realm_config_t>, ffi.Pointer<ffi.Char>)>();

  /// Configure realm to be in memory
  void realm_config_set_in_memory(
    ffi.Pointer<realm_config_t> arg0,
    bool arg1,
  ) {
    return _realm_config_set_in_memory(
      arg0,
      arg1,
    );
  }

  late final _realm_config_set_in_memoryPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<realm_config_t>,
              ffi.Bool)>>('realm_config_set_in_memory');
  late final _realm_config_set_in_memory = _realm_config_set_in_memoryPtr
      .asFunction<void Function(ffi.Pointer<realm_config_t>, bool)>();

  /// Set maximum number of active versions in the realm file allowed before an
  /// exception is thrown (default: UINT64_MAX).
  ///
  /// This function cannot fail.
  void realm_config_set_max_number_of_active_versions(
    ffi.Pointer<realm_config_t> arg0,
    int arg1,
  ) {
    return _realm_config_set_max_number_of_active_versions(
      arg0,
      arg1,
    );
  }

  late final _realm_config_set_max_number_of_active_versionsPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<realm_config_t>,
              ffi.Uint64)>>('realm_config_set_max_number_of_active_versions');
  late final _realm_config_set_max_number_of_active_versions =
      _realm_config_set_max_number_of_active_versionsPtr
          .asFunction<void Function(ffi.Pointer<realm_config_t>, int)>();

  /// Set the migration callback.
  ///
  /// The migration function is called during a migration for schema modes
  /// `RLM_SCHEMA_MODE_AUTOMATIC` and `RLM_SCHEMA_MODE_MANUAL`. The callback is
  /// invoked with a realm instance before the migration and the realm instance
  /// that is currently performing the migration.
  ///
  /// This function cannot fail.
  void realm_config_set_migration_function(
    ffi.Pointer<realm_config_t> arg0,
    realm_migration_func_t arg1,
    ffi.Pointer<ffi.Void> userdata,
    realm_free_userdata_func_t userdata_free,
  ) {
    return _realm_config_set_migration_function(
      arg0,
      arg1,
      userdata,
      userdata_free,
    );
  }

  late final _realm_config_set_migration_functionPtr = _lookup<
          ffi.NativeFunction<
              ffi.Void Function(
                  ffi.Pointer<realm_config_t>,
                  realm_migration_func_t,
                  ffi.Pointer<ffi.Void>,
                  realm_free_userdata_func_t)>>(
      'realm_config_set_migration_function');
  late final _realm_config_set_migration_function =
      _realm_config_set_migration_functionPtr.asFunction<
          void Function(ffi.Pointer<realm_config_t>, realm_migration_func_t,
              ffi.Pointer<ffi.Void>, realm_free_userdata_func_t)>();

  /// Set the path of the realm being opened.
  ///
  /// This function aborts when out of memory, but otherwise cannot fail.
  void realm_config_set_path(
    ffi.Pointer<realm_config_t> arg0,
    ffi.Pointer<ffi.Char> path,
  ) {
    return _realm_config_set_path(
      arg0,
      path,
    );
  }

  late final _realm_config_set_pathPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<realm_config_t>,
              ffi.Pointer<ffi.Char>)>>('realm_config_set_path');
  late final _realm_config_set_path = _realm_config_set_pathPtr.asFunction<
      void Function(ffi.Pointer<realm_config_t>, ffi.Pointer<ffi.Char>)>();

  /// The scheduler which this realm should be bound to (default: NULL).
  ///
  /// If NULL, the realm will be bound to the default scheduler for the current thread.
  ///
  /// This function aborts when out of memory, but otherwise cannot fail.
  void realm_config_set_scheduler(
    ffi.Pointer<realm_config_t> arg0,
    ffi.Pointer<realm_scheduler_t> arg1,
  ) {
    return _realm_config_set_scheduler(
      arg0,
      arg1,
    );
  }

  late final _realm_config_set_schedulerPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<realm_config_t>,
              ffi.Pointer<realm_scheduler_t>)>>('realm_config_set_scheduler');
  late final _realm_config_set_scheduler =
      _realm_config_set_schedulerPtr.asFunction<
          void Function(
              ffi.Pointer<realm_config_t>, ffi.Pointer<realm_scheduler_t>)>();

  /// Set the schema object for this realm.
  ///
  /// This does not take ownership of the schema object, and it should be released
  /// afterwards.
  ///
  /// This function aborts when out of memory, but otherwise cannot fail.
  ///
  /// @param schema The schema object. May be NULL, which means an empty schema.
  void realm_config_set_schema(
    ffi.Pointer<realm_config_t> arg0,
    ffi.Pointer<realm_schema_t> schema,
  ) {
    return _realm_config_set_schema(
      arg0,
      schema,
    );
  }

  late final _realm_config_set_schemaPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<realm_config_t>,
              ffi.Pointer<realm_schema_t>)>>('realm_config_set_schema');
  late final _realm_config_set_schema = _realm_config_set_schemaPtr.asFunction<
      void Function(
          ffi.Pointer<realm_config_t>, ffi.Pointer<realm_schema_t>)>();

  /// Set the schema mode.
  ///
  /// This function cannot fail.
  void realm_config_set_schema_mode(
    ffi.Pointer<realm_config_t> arg0,
    realm_schema_mode arg1,
  ) {
    return _realm_config_set_schema_mode(
      arg0,
      arg1.value,
    );
  }

  late final _realm_config_set_schema_modePtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<realm_config_t>,
              ffi.UnsignedInt)>>('realm_config_set_schema_mode');
  late final _realm_config_set_schema_mode = _realm_config_set_schema_modePtr
      .asFunction<void Function(ffi.Pointer<realm_config_t>, int)>();

  /// Set schema subset mode
  ///
  /// This function cannot fail
  void realm_config_set_schema_subset_mode(
    ffi.Pointer<realm_config_t> arg0,
    realm_schema_subset_mode arg1,
  ) {
    return _realm_config_set_schema_subset_mode(
      arg0,
      arg1.value,
    );
  }

  late final _realm_config_set_schema_subset_modePtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<realm_config_t>,
              ffi.UnsignedInt)>>('realm_config_set_schema_subset_mode');
  late final _realm_config_set_schema_subset_mode =
      _realm_config_set_schema_subset_modePtr
          .asFunction<void Function(ffi.Pointer<realm_config_t>, int)>();

  /// Set the schema version of the schema.
  ///
  /// This function cannot fail.
  void realm_config_set_schema_version(
    ffi.Pointer<realm_config_t> arg0,
    int version,
  ) {
    return _realm_config_set_schema_version(
      arg0,
      version,
    );
  }

  late final _realm_config_set_schema_versionPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<realm_config_t>,
              ffi.Uint64)>>('realm_config_set_schema_version');
  late final _realm_config_set_schema_version =
      _realm_config_set_schema_versionPtr
          .asFunction<void Function(ffi.Pointer<realm_config_t>, int)>();

  /// Set the should-compact-on-launch callback.
  ///
  /// The callback is invoked the first time a realm file is opened in this process
  /// to decide whether the realm file should be compacted.
  ///
  /// Note: If another process has the realm file open, it will not be compacted.
  ///
  /// This function cannot fail.
  void realm_config_set_should_compact_on_launch_function(
    ffi.Pointer<realm_config_t> arg0,
    realm_should_compact_on_launch_func_t arg1,
    ffi.Pointer<ffi.Void> userdata,
    realm_free_userdata_func_t userdata_free,
  ) {
    return _realm_config_set_should_compact_on_launch_function(
      arg0,
      arg1,
      userdata,
      userdata_free,
    );
  }

  late final _realm_config_set_should_compact_on_launch_functionPtr = _lookup<
          ffi.NativeFunction<
              ffi.Void Function(
                  ffi.Pointer<realm_config_t>,
                  realm_should_compact_on_launch_func_t,
                  ffi.Pointer<ffi.Void>,
                  realm_free_userdata_func_t)>>(
      'realm_config_set_should_compact_on_launch_function');
  late final _realm_config_set_should_compact_on_launch_function =
      _realm_config_set_should_compact_on_launch_functionPtr.asFunction<
          void Function(
              ffi.Pointer<realm_config_t>,
              realm_should_compact_on_launch_func_t,
              ffi.Pointer<ffi.Void>,
              realm_free_userdata_func_t)>();

  /// The overloaded Realm::convert function offers a way to copy and/or convert a realm.
  ///
  /// The following options are supported:
  /// - local -> local (config or path)
  /// - local -> sync (config only)
  /// - sync -> local (config only)
  /// - sync -> sync  (config or path)
  /// - sync -> bundlable sync (client file identifier removed)
  ///
  /// Note that for bundled realms it is required that all local changes are synchronized with the
  /// server before the copy can be written. This is to be sure that the file can be used as a
  /// stating point for a newly installed application. The function will throw if there are
  /// pending uploads.
  /// /
  /// /**
  /// Copy or convert a Realm using a config.
  ///
  /// If the file already exists and merge_with_existing is true, data will be copied over object per object.
  /// When merging, all classes must have a pk called '_id" otherwise an exception is thrown.
  /// If the file exists and merge_with_existing is false, an exception is thrown.
  /// If the file does not exist, the realm file will be exported to the new location and if the
  /// configuration object contains a sync part, a sync history will be synthesized.
  ///
  /// @param config The realm configuration that should be used to create a copy.
  /// This can be a local or a synced Realm, encrypted or not.
  /// @param merge_with_existing If this is true and the destination file exists, data will be copied over object by
  /// object. Otherwise, if this is false and the destination file exists, an exception is thrown.
  bool realm_convert_with_config(
    ffi.Pointer<realm_t> realm,
    ffi.Pointer<realm_config_t> config,
    bool merge_with_existing,
  ) {
    return _realm_convert_with_config(
      realm,
      config,
      merge_with_existing,
    );
  }

  late final _realm_convert_with_configPtr = _lookup<
      ffi.NativeFunction<
          ffi.Bool Function(ffi.Pointer<realm_t>, ffi.Pointer<realm_config_t>,
              ffi.Bool)>>('realm_convert_with_config');
  late final _realm_convert_with_config =
      _realm_convert_with_configPtr.asFunction<
          bool Function(
              ffi.Pointer<realm_t>, ffi.Pointer<realm_config_t>, bool)>();

  /// Copy a Realm using a path.
  ///
  /// @param path The path the realm should be copied to. Local realms will remain local, synced
  /// realms will remain synced realms.
  /// @param encryption_key The optional encryption key for the new realm.
  /// @param merge_with_existing If this is true and the destination file exists, data will be copied over object by
  /// object.
  /// Otherwise, if this is false and the destination file exists, an exception is thrown.
  bool realm_convert_with_path(
    ffi.Pointer<realm_t> realm,
    ffi.Pointer<ffi.Char> path,
    realm_binary_t encryption_key,
    bool merge_with_existing,
  ) {
    return _realm_convert_with_path(
      realm,
      path,
      encryption_key,
      merge_with_existing,
    );
  }

  late final _realm_convert_with_pathPtr = _lookup<
      ffi.NativeFunction<
          ffi.Bool Function(ffi.Pointer<realm_t>, ffi.Pointer<ffi.Char>,
              realm_binary_t, ffi.Bool)>>('realm_convert_with_path');
  late final _realm_convert_with_path = _realm_convert_with_pathPtr.asFunction<
      bool Function(
          ffi.Pointer<realm_t>, ffi.Pointer<ffi.Char>, realm_binary_t, bool)>();

  /// Helper method for making it easier to to convert SDK input to the underlying
  /// `realm_key_path_array_t`.
  ///
  /// @return A pointer to the converted key path array. NULL in case of an error.
  ffi.Pointer<realm_key_path_array_t> realm_create_key_path_array(
    ffi.Pointer<realm_t> realm,
    int object_class_key,
    int num_key_paths,
    ffi.Pointer<ffi.Pointer<ffi.Char>> user_key_paths,
  ) {
    return _realm_create_key_path_array(
      realm,
      object_class_key,
      num_key_paths,
      user_key_paths,
    );
  }

  late final _realm_create_key_path_arrayPtr = _lookup<
          ffi.NativeFunction<
              ffi.Pointer<realm_key_path_array_t> Function(
                  ffi.Pointer<realm_t>,
                  realm_class_key_t,
                  ffi.Size,
                  ffi.Pointer<ffi.Pointer<ffi.Char>>)>>(
      'realm_create_key_path_array');
  late final _realm_create_key_path_array =
      _realm_create_key_path_arrayPtr.asFunction<
          ffi.Pointer<realm_key_path_array_t> Function(ffi.Pointer<realm_t>,
              int, int, ffi.Pointer<ffi.Pointer<ffi.Char>>)>();

  /// Get a thread-safe reference representing the same underlying object as some
  /// API object.
  ///
  /// The thread safe reference can be passed to a different thread and resolved
  /// against a different `realm_t` instance, which succeeds if the underlying
  /// object still exists.
  ///
  /// The following types can produce thread safe references:
  ///
  /// - `realm_object_t`
  /// - `realm_results_t`
  /// - `realm_list_t`
  /// - `realm_t`
  ///
  /// This does not assume ownership of the object, except for `realm_t`, where the
  /// instance is transferred by value, and must be transferred back to the current
  /// thread to be used. Note that the `realm_thread_safe_reference_t` object must
  /// still be destroyed after having been converted into a `realm_t` object.
  ///
  /// @return A non-null pointer if no exception occurred.
  ffi.Pointer<realm_thread_safe_reference_t> realm_create_thread_safe_reference(
    ffi.Pointer<ffi.Void> arg0,
  ) {
    return _realm_create_thread_safe_reference(
      arg0,
    );
  }

  late final _realm_create_thread_safe_referencePtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<realm_thread_safe_reference_t> Function(
              ffi.Pointer<ffi.Void>)>>('realm_create_thread_safe_reference');
  late final _realm_create_thread_safe_reference =
      _realm_create_thread_safe_referencePtr.asFunction<
          ffi.Pointer<realm_thread_safe_reference_t> Function(
              ffi.Pointer<ffi.Void>)>();

  void realm_dart_attach_logger(
    int port,
  ) {
    return _realm_dart_attach_logger(
      port,
    );
  }

  late final _realm_dart_attach_loggerPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(Dart_Port)>>(
          'realm_dart_attach_logger');
  late final _realm_dart_attach_logger =
      _realm_dart_attach_loggerPtr.asFunction<void Function(int)>();

  ffi.Pointer<realm_scheduler_t> realm_dart_create_scheduler(
    int isolateId,
    int port,
  ) {
    return _realm_dart_create_scheduler(
      isolateId,
      port,
    );
  }

  late final _realm_dart_create_schedulerPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<realm_scheduler_t> Function(
              ffi.Uint64, Dart_Port)>>('realm_dart_create_scheduler');
  late final _realm_dart_create_scheduler = _realm_dart_create_schedulerPtr
      .asFunction<ffi.Pointer<realm_scheduler_t> Function(int, int)>();

  realm_decimal128_t realm_dart_decimal128_add(
    realm_decimal128_t x,
    realm_decimal128_t y,
  ) {
    return _realm_dart_decimal128_add(
      x,
      y,
    );
  }

  late final _realm_dart_decimal128_addPtr = _lookup<
      ffi.NativeFunction<
          realm_decimal128_t Function(realm_decimal128_t,
              realm_decimal128_t)>>('realm_dart_decimal128_add');
  late final _realm_dart_decimal128_add =
      _realm_dart_decimal128_addPtr.asFunction<
          realm_decimal128_t Function(
              realm_decimal128_t, realm_decimal128_t)>();

  int realm_dart_decimal128_compare_to(
    realm_decimal128_t x,
    realm_decimal128_t y,
  ) {
    return _realm_dart_decimal128_compare_to(
      x,
      y,
    );
  }

  late final _realm_dart_decimal128_compare_toPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(realm_decimal128_t,
              realm_decimal128_t)>>('realm_dart_decimal128_compare_to');
  late final _realm_dart_decimal128_compare_to =
      _realm_dart_decimal128_compare_toPtr
          .asFunction<int Function(realm_decimal128_t, realm_decimal128_t)>();

  /// work-around for Dart FFI issue
  realm_decimal128_t realm_dart_decimal128_copy(
    realm_decimal128_t x,
  ) {
    return _realm_dart_decimal128_copy(
      x,
    );
  }

  late final _realm_dart_decimal128_copyPtr = _lookup<
          ffi.NativeFunction<realm_decimal128_t Function(realm_decimal128_t)>>(
      'realm_dart_decimal128_copy');
  late final _realm_dart_decimal128_copy = _realm_dart_decimal128_copyPtr
      .asFunction<realm_decimal128_t Function(realm_decimal128_t)>();

  realm_decimal128_t realm_dart_decimal128_divide(
    realm_decimal128_t x,
    realm_decimal128_t y,
  ) {
    return _realm_dart_decimal128_divide(
      x,
      y,
    );
  }

  late final _realm_dart_decimal128_dividePtr = _lookup<
      ffi.NativeFunction<
          realm_decimal128_t Function(realm_decimal128_t,
              realm_decimal128_t)>>('realm_dart_decimal128_divide');
  late final _realm_dart_decimal128_divide =
      _realm_dart_decimal128_dividePtr.asFunction<
          realm_decimal128_t Function(
              realm_decimal128_t, realm_decimal128_t)>();

  bool realm_dart_decimal128_equal(
    realm_decimal128_t x,
    realm_decimal128_t y,
  ) {
    return _realm_dart_decimal128_equal(
      x,
      y,
    );
  }

  late final _realm_dart_decimal128_equalPtr = _lookup<
      ffi.NativeFunction<
          ffi.Bool Function(realm_decimal128_t,
              realm_decimal128_t)>>('realm_dart_decimal128_equal');
  late final _realm_dart_decimal128_equal = _realm_dart_decimal128_equalPtr
      .asFunction<bool Function(realm_decimal128_t, realm_decimal128_t)>();

  realm_decimal128_t realm_dart_decimal128_from_int64(
    int low,
  ) {
    return _realm_dart_decimal128_from_int64(
      low,
    );
  }

  late final _realm_dart_decimal128_from_int64Ptr =
      _lookup<ffi.NativeFunction<realm_decimal128_t Function(ffi.Int64)>>(
          'realm_dart_decimal128_from_int64');
  late final _realm_dart_decimal128_from_int64 =
      _realm_dart_decimal128_from_int64Ptr
          .asFunction<realm_decimal128_t Function(int)>();

  realm_decimal128_t realm_dart_decimal128_from_string(
    ffi.Pointer<ffi.Char> string,
  ) {
    return _realm_dart_decimal128_from_string(
      string,
    );
  }

  late final _realm_dart_decimal128_from_stringPtr = _lookup<
          ffi
          .NativeFunction<realm_decimal128_t Function(ffi.Pointer<ffi.Char>)>>(
      'realm_dart_decimal128_from_string');
  late final _realm_dart_decimal128_from_string =
      _realm_dart_decimal128_from_stringPtr
          .asFunction<realm_decimal128_t Function(ffi.Pointer<ffi.Char>)>();

  bool realm_dart_decimal128_greater_than(
    realm_decimal128_t x,
    realm_decimal128_t y,
  ) {
    return _realm_dart_decimal128_greater_than(
      x,
      y,
    );
  }

  late final _realm_dart_decimal128_greater_thanPtr = _lookup<
      ffi.NativeFunction<
          ffi.Bool Function(realm_decimal128_t,
              realm_decimal128_t)>>('realm_dart_decimal128_greater_than');
  late final _realm_dart_decimal128_greater_than =
      _realm_dart_decimal128_greater_thanPtr
          .asFunction<bool Function(realm_decimal128_t, realm_decimal128_t)>();

  bool realm_dart_decimal128_is_nan(
    realm_decimal128_t x,
  ) {
    return _realm_dart_decimal128_is_nan(
      x,
    );
  }

  late final _realm_dart_decimal128_is_nanPtr =
      _lookup<ffi.NativeFunction<ffi.Bool Function(realm_decimal128_t)>>(
          'realm_dart_decimal128_is_nan');
  late final _realm_dart_decimal128_is_nan = _realm_dart_decimal128_is_nanPtr
      .asFunction<bool Function(realm_decimal128_t)>();

  bool realm_dart_decimal128_less_than(
    realm_decimal128_t x,
    realm_decimal128_t y,
  ) {
    return _realm_dart_decimal128_less_than(
      x,
      y,
    );
  }

  late final _realm_dart_decimal128_less_thanPtr = _lookup<
      ffi.NativeFunction<
          ffi.Bool Function(realm_decimal128_t,
              realm_decimal128_t)>>('realm_dart_decimal128_less_than');
  late final _realm_dart_decimal128_less_than =
      _realm_dart_decimal128_less_thanPtr
          .asFunction<bool Function(realm_decimal128_t, realm_decimal128_t)>();

  realm_decimal128_t realm_dart_decimal128_multiply(
    realm_decimal128_t x,
    realm_decimal128_t y,
  ) {
    return _realm_dart_decimal128_multiply(
      x,
      y,
    );
  }

  late final _realm_dart_decimal128_multiplyPtr = _lookup<
      ffi.NativeFunction<
          realm_decimal128_t Function(realm_decimal128_t,
              realm_decimal128_t)>>('realm_dart_decimal128_multiply');
  late final _realm_dart_decimal128_multiply =
      _realm_dart_decimal128_multiplyPtr.asFunction<
          realm_decimal128_t Function(
              realm_decimal128_t, realm_decimal128_t)>();

  realm_decimal128_t realm_dart_decimal128_nan() {
    return _realm_dart_decimal128_nan();
  }

  late final _realm_dart_decimal128_nanPtr =
      _lookup<ffi.NativeFunction<realm_decimal128_t Function()>>(
          'realm_dart_decimal128_nan');
  late final _realm_dart_decimal128_nan =
      _realm_dart_decimal128_nanPtr.asFunction<realm_decimal128_t Function()>();

  realm_decimal128_t realm_dart_decimal128_negate(
    realm_decimal128_t x,
  ) {
    return _realm_dart_decimal128_negate(
      x,
    );
  }

  late final _realm_dart_decimal128_negatePtr = _lookup<
          ffi.NativeFunction<realm_decimal128_t Function(realm_decimal128_t)>>(
      'realm_dart_decimal128_negate');
  late final _realm_dart_decimal128_negate = _realm_dart_decimal128_negatePtr
      .asFunction<realm_decimal128_t Function(realm_decimal128_t)>();

  realm_decimal128_t realm_dart_decimal128_subtract(
    realm_decimal128_t x,
    realm_decimal128_t y,
  ) {
    return _realm_dart_decimal128_subtract(
      x,
      y,
    );
  }

  late final _realm_dart_decimal128_subtractPtr = _lookup<
      ffi.NativeFunction<
          realm_decimal128_t Function(realm_decimal128_t,
              realm_decimal128_t)>>('realm_dart_decimal128_subtract');
  late final _realm_dart_decimal128_subtract =
      _realm_dart_decimal128_subtractPtr.asFunction<
          realm_decimal128_t Function(
              realm_decimal128_t, realm_decimal128_t)>();

  int realm_dart_decimal128_to_int64(
    realm_decimal128_t x,
  ) {
    return _realm_dart_decimal128_to_int64(
      x,
    );
  }

  late final _realm_dart_decimal128_to_int64Ptr =
      _lookup<ffi.NativeFunction<ffi.Int64 Function(realm_decimal128_t)>>(
          'realm_dart_decimal128_to_int64');
  late final _realm_dart_decimal128_to_int64 =
      _realm_dart_decimal128_to_int64Ptr
          .asFunction<int Function(realm_decimal128_t)>();

  realm_string_t realm_dart_decimal128_to_string(
    realm_decimal128_t x,
  ) {
    return _realm_dart_decimal128_to_string(
      x,
    );
  }

  late final _realm_dart_decimal128_to_stringPtr =
      _lookup<ffi.NativeFunction<realm_string_t Function(realm_decimal128_t)>>(
          'realm_dart_decimal128_to_string');
  late final _realm_dart_decimal128_to_string =
      _realm_dart_decimal128_to_stringPtr
          .asFunction<realm_string_t Function(realm_decimal128_t)>();

  void realm_dart_delete_persistent_handle(
    ffi.Pointer<ffi.Void> handle,
  ) {
    return _realm_dart_delete_persistent_handle(
      handle,
    );
  }

  late final _realm_dart_delete_persistent_handlePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>(
          'realm_dart_delete_persistent_handle');
  late final _realm_dart_delete_persistent_handle =
      _realm_dart_delete_persistent_handlePtr
          .asFunction<void Function(ffi.Pointer<ffi.Void>)>();

  void realm_dart_detach_logger(
    int port,
  ) {
    return _realm_dart_detach_logger(
      port,
    );
  }

  late final _realm_dart_detach_loggerPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(Dart_Port)>>(
          'realm_dart_detach_logger');
  late final _realm_dart_detach_logger =
      _realm_dart_detach_loggerPtr.asFunction<void Function(int)>();

  /// implemented for Android only
  ffi.Pointer<ffi.Char> realm_dart_get_bundle_id() {
    return _realm_dart_get_bundle_id();
  }

  late final _realm_dart_get_bundle_idPtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Char> Function()>>(
          'realm_dart_get_bundle_id');
  late final _realm_dart_get_bundle_id = _realm_dart_get_bundle_idPtr
      .asFunction<ffi.Pointer<ffi.Char> Function()>();

  ffi.Pointer<ffi.Char> realm_dart_get_device_name() {
    return _realm_dart_get_device_name();
  }

  late final _realm_dart_get_device_namePtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Char> Function()>>(
          'realm_dart_get_device_name');
  late final _realm_dart_get_device_name = _realm_dart_get_device_namePtr
      .asFunction<ffi.Pointer<ffi.Char> Function()>();

  ffi.Pointer<ffi.Char> realm_dart_get_device_version() {
    return _realm_dart_get_device_version();
  }

  late final _realm_dart_get_device_versionPtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Char> Function()>>(
          'realm_dart_get_device_version');
  late final _realm_dart_get_device_version = _realm_dart_get_device_versionPtr
      .asFunction<ffi.Pointer<ffi.Char> Function()>();

  /// implemented for iOS and Android only
  ffi.Pointer<ffi.Char> realm_dart_get_files_path() {
    return _realm_dart_get_files_path();
  }

  late final _realm_dart_get_files_pathPtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Char> Function()>>(
          'realm_dart_get_files_path');
  late final _realm_dart_get_files_path = _realm_dart_get_files_pathPtr
      .asFunction<ffi.Pointer<ffi.Char> Function()>();

  int realm_dart_get_thread_id() {
    return _realm_dart_get_thread_id();
  }

  late final _realm_dart_get_thread_idPtr =
      _lookup<ffi.NativeFunction<ffi.Uint64 Function()>>(
          'realm_dart_get_thread_id');
  late final _realm_dart_get_thread_id =
      _realm_dart_get_thread_idPtr.asFunction<int Function()>();

  void realm_dart_init_debug_logger() {
    return _realm_dart_init_debug_logger();
  }

  late final _realm_dart_init_debug_loggerPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function()>>(
          'realm_dart_init_debug_logger');
  late final _realm_dart_init_debug_logger =
      _realm_dart_init_debug_loggerPtr.asFunction<void Function()>();

  void realm_dart_initializeDartApiDL(
    ffi.Pointer<ffi.Void> data,
  ) {
    return _realm_dart_initializeDartApiDL(
      data,
    );
  }

  late final _realm_dart_initializeDartApiDLPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>(
          'realm_dart_initializeDartApiDL');
  late final _realm_dart_initializeDartApiDL =
      _realm_dart_initializeDartApiDLPtr
          .asFunction<void Function(ffi.Pointer<ffi.Void>)>();

  void realm_dart_invoke_unlock_callback(
    ffi.Pointer<ffi.Void> error,
    ffi.Pointer<ffi.Void> unlockFunc,
  ) {
    return _realm_dart_invoke_unlock_callback(
      error,
      unlockFunc,
    );
  }

  late final _realm_dart_invoke_unlock_callbackPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>>('realm_dart_invoke_unlock_callback');
  late final _realm_dart_invoke_unlock_callback =
      _realm_dart_invoke_unlock_callbackPtr.asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  ffi.Pointer<ffi.Char> realm_dart_library_version() {
    return _realm_dart_library_version();
  }

  late final _realm_dart_library_versionPtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Char> Function()>>(
          'realm_dart_library_version');
  late final _realm_dart_library_version = _realm_dart_library_versionPtr
      .asFunction<ffi.Pointer<ffi.Char> Function()>();

  void realm_dart_log(
    realm_log_level level,
    ffi.Pointer<ffi.Char> category,
    ffi.Pointer<ffi.Char> message,
  ) {
    return _realm_dart_log(
      level.value,
      category,
      message,
    );
  }

  late final _realm_dart_logPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.UnsignedInt, ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>)>>('realm_dart_log');
  late final _realm_dart_log = _realm_dart_logPtr.asFunction<
      void Function(int, ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>();

  ffi.Pointer<ffi.Void> realm_dart_object_to_persistent_handle(
    Object handle,
  ) {
    return _realm_dart_object_to_persistent_handle(
      handle,
    );
  }

  late final _realm_dart_object_to_persistent_handlePtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function(ffi.Handle)>>(
          'realm_dart_object_to_persistent_handle');
  late final _realm_dart_object_to_persistent_handle =
      _realm_dart_object_to_persistent_handlePtr
          .asFunction<ffi.Pointer<ffi.Void> Function(Object)>();

  Object realm_dart_persistent_handle_to_object(
    ffi.Pointer<ffi.Void> handle,
  ) {
    return _realm_dart_persistent_handle_to_object(
      handle,
    );
  }

  late final _realm_dart_persistent_handle_to_objectPtr =
      _lookup<ffi.NativeFunction<ffi.Handle Function(ffi.Pointer<ffi.Void>)>>(
          'realm_dart_persistent_handle_to_object');
  late final _realm_dart_persistent_handle_to_object =
      _realm_dart_persistent_handle_to_objectPtr
          .asFunction<Object Function(ffi.Pointer<ffi.Void>)>();

  void realm_dart_scheduler_invoke(
    int isolateId,
    ffi.Pointer<ffi.Void> userData,
  ) {
    return _realm_dart_scheduler_invoke(
      isolateId,
      userData,
    );
  }

  late final _realm_dart_scheduler_invokePtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Uint64,
              ffi.Pointer<ffi.Void>)>>('realm_dart_scheduler_invoke');
  late final _realm_dart_scheduler_invoke = _realm_dart_scheduler_invokePtr
      .asFunction<void Function(int, ffi.Pointer<ffi.Void>)>();

  /// implemented for iOS only (for now - valid for all posix)
  /// /**
  ///  * Set the soft limit on number of open files
  ///  * @param limit The requested limit. If less than zero no attempt is made.
  ///  * @param[out] out_limit The actual limit set.
  ///  *
  ///  * @return true if no error occurred.
  ///  *
  ///  * @throws RLM_ERR_FILE_PERMISSION_DENIED if the operation was not permitted.
  ///  */
  bool realm_dart_set_and_get_rlimit(
    int limit,
    ffi.Pointer<ffi.Long> out_limit,
  ) {
    return _realm_dart_set_and_get_rlimit(
      limit,
      out_limit,
    );
  }

  late final _realm_dart_set_and_get_rlimitPtr = _lookup<
          ffi
          .NativeFunction<ffi.Bool Function(ffi.Long, ffi.Pointer<ffi.Long>)>>(
      'realm_dart_set_and_get_rlimit');
  late final _realm_dart_set_and_get_rlimit = _realm_dart_set_and_get_rlimitPtr
      .asFunction<bool Function(int, ffi.Pointer<ffi.Long>)>();

  void realm_dart_userdata_async_free(
    ffi.Pointer<ffi.Void> userdata,
  ) {
    return _realm_dart_userdata_async_free(
      userdata,
    );
  }

  late final _realm_dart_userdata_async_freePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>(
          'realm_dart_userdata_async_free');
  late final _realm_dart_userdata_async_free =
      _realm_dart_userdata_async_freePtr
          .asFunction<void Function(ffi.Pointer<ffi.Void>)>();

  realm_dart_userdata_async_t realm_dart_userdata_async_new(
    Object handle,
    ffi.Pointer<ffi.Void> callback,
    ffi.Pointer<realm_scheduler_t> scheduler,
  ) {
    return _realm_dart_userdata_async_new(
      handle,
      callback,
      scheduler,
    );
  }

  late final _realm_dart_userdata_async_newPtr = _lookup<
          ffi.NativeFunction<
              realm_dart_userdata_async_t Function(ffi.Handle,
                  ffi.Pointer<ffi.Void>, ffi.Pointer<realm_scheduler_t>)>>(
      'realm_dart_userdata_async_new');
  late final _realm_dart_userdata_async_new =
      _realm_dart_userdata_async_newPtr.asFunction<
          realm_dart_userdata_async_t Function(
              Object, ffi.Pointer<ffi.Void>, ffi.Pointer<realm_scheduler_t>)>();

  /// Deletes the following files for the given `realm_file_path` if they exist:
  /// - the Realm file itself
  /// - the .management folder
  /// - the .note file
  /// - the .log file
  ///
  /// The .lock file for this Realm cannot and will not be deleted as this is unsafe.
  /// If a different process / thread is accessing the Realm at the same time a corrupt state
  /// could be the result and checking for a single process state is not possible here.
  ///
  /// @param realm_file_path The path to the Realm file. All files will be derived from this.
  /// @param[out] did_delete_realm If non-null, set to true if the primary Realm file was deleted.
  /// Discard value if the function returns an error.
  ///
  /// @return true if no error occurred.
  ///
  /// @throws RLM_ERR_FILE_PERMISSION_DENIED if the operation was not permitted.
  /// @throws RLM_ERR_FILE_ACCESS_ERROR for any other error while trying to delete the file or folder.
  /// @throws RLM_ERR_DELETE_OPENED_REALM if the function was called on an open Realm.
  bool realm_delete_files(
    ffi.Pointer<ffi.Char> realm_file_path,
    ffi.Pointer<ffi.Bool> did_delete_realm,
  ) {
    return _realm_delete_files(
      realm_file_path,
      did_delete_realm,
    );
  }

  late final _realm_delete_filesPtr = _lookup<
      ffi.NativeFunction<
          ffi.Bool Function(ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Bool>)>>('realm_delete_files');
  late final _realm_delete_files = _realm_delete_filesPtr.asFunction<
      bool Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Bool>)>();

  void realm_detach_finalizer(
    ffi.Pointer<ffi.Void> finalizableHandle,
    Object handle,
  ) {
    return _realm_detach_finalizer(
      finalizableHandle,
      handle,
    );
  }

  late final _realm_detach_finalizerPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<ffi.Void>, ffi.Handle)>>('realm_detach_finalizer');
  late final _realm_detach_finalizer = _realm_detach_finalizerPtr
      .asFunction<void Function(ffi.Pointer<ffi.Void>, Object)>();

  /// Subscribe to notifications for this object.
  ///
  /// @return A non-null pointer if no exception occurred.
  ffi.Pointer<realm_notification_token_t>
      realm_dictionary_add_notification_callback(
    ffi.Pointer<realm_dictionary_t> arg0,
    ffi.Pointer<ffi.Void> userdata,
    realm_free_userdata_func_t userdata_free,
    ffi.Pointer<realm_key_path_array_t> key_path_array,
    realm_on_dictionary_change_func_t on_change,
  ) {
    return _realm_dictionary_add_notification_callback(
      arg0,
      userdata,
      userdata_free,
      key_path_array,
      on_change,
    );
  }

  late final _realm_dictionary_add_notification_callbackPtr = _lookup<
          ffi.NativeFunction<
              ffi.Pointer<realm_notification_token_t> Function(
                  ffi.Pointer<realm_dictionary_t>,
                  ffi.Pointer<ffi.Void>,
                  realm_free_userdata_func_t,
                  ffi.Pointer<realm_key_path_array_t>,
                  realm_on_dictionary_change_func_t)>>(
      'realm_dictionary_add_notification_callback');
  late final _realm_dictionary_add_notification_callback =
      _realm_dictionary_add_notification_callbackPtr.asFunction<
          ffi.Pointer<realm_notification_token_t> Function(
              ffi.Pointer<realm_dictionary_t>,
              ffi.Pointer<ffi.Void>,
              realm_free_userdata_func_t,
              ffi.Pointer<realm_key_path_array_t>,
              realm_on_dictionary_change_func_t)>();

  /// Clear a dictionary.
  ///
  /// @return True if no exception occurred.
  bool realm_dictionary_clear(
    ffi.Pointer<realm_dictionary_t> arg0,
  ) {
    return _realm_dictionary_clear(
      arg0,
    );
  }

  late final _realm_dictionary_clearPtr = _lookup<
          ffi
          .NativeFunction<ffi.Bool Function(ffi.Pointer<realm_dictionary_t>)>>(
      'realm_dictionary_clear');
  late final _realm_dictionary_clear = _realm_dictionary_clearPtr
      .asFunction<bool Function(ffi.Pointer<realm_dictionary_t>)>();

  /// Check if the dictionary contains a certain key
  ///
  /// @param key to search in the dictionary
  /// @param found True if the such key exists
  /// @return True if no exception occurred
  bool realm_dictionary_contains_key(
    ffi.Pointer<realm_dictionary_t> arg0,
    realm_value_t key,
    ffi.Pointer<ffi.Bool> found,
  ) {
    return _realm_dictionary_contains_key(
      arg0,
      key,
      found,
    );
  }

  late final _realm_dictionary_contains_keyPtr = _lookup<
      ffi.NativeFunction<
          ffi.Bool Function(ffi.Pointer<realm_dictionary_t>, realm_value_t,
              ffi.Pointer<ffi.Bool>)>>('realm_dictionary_contains_key');
  late final _realm_dictionary_contains_key =
      _realm_dictionary_contains_keyPtr.asFunction<
          bool Function(ffi.Pointer<realm_dictionary_t>, realm_value_t,
              ffi.Pointer<ffi.Bool>)>();

  /// Check if the dictionary contains a certain value
  ///
  /// @param value to search in the dictionary
  /// @param index the index of the value in the dictionry if such value exists
  /// @return True if no exception occurred
  bool realm_dictionary_contains_value(
    ffi.Pointer<realm_dictionary_t> arg0,
    realm_value_t value,
    ffi.Pointer<ffi.Size> index,
  ) {
    return _realm_dictionary_contains_value(
      arg0,
      value,
      index,
    );
  }

  late final _realm_dictionary_contains_valuePtr = _lookup<
      ffi.NativeFunction<
          ffi.Bool Function(ffi.Pointer<realm_dictionary_t>, realm_value_t,
              ffi.Pointer<ffi.Size>)>>('realm_dictionary_contains_value');
  late final _realm_dictionary_contains_value =
      _realm_dictionary_contains_valuePtr.asFunction<
          bool Function(ffi.Pointer<realm_dictionary_t>, realm_value_t,
              ffi.Pointer<ffi.Size>)>();

  /// Erase a dictionary element.
  ///
  /// @param key The key of the element to erase.
  /// @param out_erased If non-null, will be set to true if the element was found
  /// and erased.
  /// @return True if no exception occurred.
  bool realm_dictionary_erase(
    ffi.Pointer<realm_dictionary_t> arg0,
    realm_value_t key,
    ffi.Pointer<ffi.Bool> out_erased,
  ) {
    return _realm_dictionary_erase(
      arg0,
      key,
      out_erased,
    );
  }

  late final _realm_dictionary_erasePtr = _lookup<
      ffi.NativeFunction<
          ffi.Bool Function(ffi.Pointer<realm_dictionary_t>, realm_value_t,
              ffi.Pointer<ffi.Bool>)>>('realm_dictionary_erase');
  late final _realm_dictionary_erase = _realm_dictionary_erasePtr.asFunction<
      bool Function(ffi.Pointer<realm_dictionary_t>, realm_value_t,
          ffi.Pointer<ffi.Bool>)>();

  /// Find an element in a dictionary.
  ///
  /// @param key The key to look for.
  /// @param out_value If non-null, the value for the corresponding key.
  /// @param out_found If non-null, will be set to true if the dictionary contained the key.
  /// @return True if no exception occurred.
  bool realm_dictionary_find(
    ffi.Pointer<realm_dictionary_t> arg0,
    realm_value_t key,
    ffi.Pointer<realm_value_t> out_value,
    ffi.Pointer<ffi.Bool> out_found,
  ) {
    return _realm_dictionary_find(
      arg0,
      key,
      out_value,
      out_found,
    );
  }

  late final _realm_dictionary_findPtr = _lookup<
      ffi.NativeFunction<
          ffi.Bool Function(
              ffi.Pointer<realm_dictionary_t>,
              realm_value_t,
              ffi.Pointer<realm_value_t>,
              ffi.Pointer<ffi.Bool>)>>('realm_dictionary_find');
  late final _realm_dictionary_find = _realm_dictionary_findPtr.asFunction<
      bool Function(ffi.Pointer<realm_dictionary_t>, realm_value_t,
          ffi.Pointer<realm_value_t>, ffi.Pointer<ffi.Bool>)>();

  /// Get an dictionary from a thread-safe reference, potentially originating in a
  /// different `realm_t` instance
  ffi.Pointer<realm_dictionary_t> realm_dictionary_from_thread_safe_reference(
    ffi.Pointer<realm_t> arg0,
    ffi.Pointer<realm_thread_safe_reference_t> arg1,
  ) {
    return _realm_dictionary_from_thread_safe_reference(
      arg0,
      arg1,
    );
  }

  late final _realm_dictionary_from_thread_safe_referencePtr = _lookup<
          ffi.NativeFunction<
              ffi.Pointer<realm_dictionary_t> Function(ffi.Pointer<realm_t>,
                  ffi.Pointer<realm_thread_safe_reference_t>)>>(
      'realm_dictionary_from_thread_safe_reference');
  late final _realm_dictionary_from_thread_safe_reference =
      _realm_dictionary_from_thread_safe_referencePtr.asFunction<
          ffi.Pointer<realm_dictionary_t> Function(ffi.Pointer<realm_t>,
              ffi.Pointer<realm_thread_safe_reference_t>)>();

  /// Get the key-value pair at @a index.
  ///
  /// Note that the indices of elements in the dictionary move around as other
  /// elements are inserted/removed.
  ///
  /// @param index The index in the dictionary.
  /// @param out_key If non-null, will be set to the key at the corresponding index.
  /// @param out_value If non-null, will be set to the value at the corresponding index.
  /// @return True if no exception occurred.
  bool realm_dictionary_get(
    ffi.Pointer<realm_dictionary_t> arg0,
    int index,
    ffi.Pointer<realm_value_t> out_key,
    ffi.Pointer<realm_value_t> out_value,
  ) {
    return _realm_dictionary_get(
      arg0,
      index,
      out_key,
      out_value,
    );
  }

  late final _realm_dictionary_getPtr = _lookup<
      ffi.NativeFunction<
          ffi.Bool Function(
              ffi.Pointer<realm_dictionary_t>,
              ffi.Size,
              ffi.Pointer<realm_value_t>,
              ffi.Pointer<realm_value_t>)>>('realm_dictionary_get');
  late final _realm_dictionary_get = _realm_dictionary_getPtr.asFunction<
      bool Function(ffi.Pointer<realm_dictionary_t>, int,
          ffi.Pointer<realm_value_t>, ffi.Pointer<realm_value_t>)>();

  /// Returns the list of keys changed for the dictionary passed as argument.
  /// The user must assure that there is enough memory to accomodate all the keys
  /// calling `realm_dictionary_get_changes` before.
  ///
  /// @param changes valid ptr to the dictionary changes structure
  /// @param deletions list of deleted keys
  /// @param deletions_size size of the list of deleted keys
  /// @param insertions list of inserted keys
  /// @param insertions_size size of the list of inserted keys
  /// @param modifications list of modified keys
  /// @param modification_size size of the list of modified keys
  /// @param collection_was_cleared whether or not the collection was cleared
  void realm_dictionary_get_changed_keys(
    ffi.Pointer<realm_dictionary_changes_t> changes,
    ffi.Pointer<realm_value_t> deletions,
    ffi.Pointer<ffi.Size> deletions_size,
    ffi.Pointer<realm_value_t> insertions,
    ffi.Pointer<ffi.Size> insertions_size,
    ffi.Pointer<realm_value_t> modifications,
    ffi.Pointer<ffi.Size> modification_size,
    ffi.Pointer<ffi.Bool> collection_was_cleared,
  ) {
    return _realm_dictionary_get_changed_keys(
      changes,
      deletions,
      deletions_size,
      insertions,
      insertions_size,
      modifications,
      modification_size,
      collection_was_cleared,
    );
  }

  late final _realm_dictionary_get_changed_keysPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<realm_dictionary_changes_t>,
              ffi.Pointer<realm_value_t>,
              ffi.Pointer<ffi.Size>,
              ffi.Pointer<realm_value_t>,
              ffi.Pointer<ffi.Size>,
              ffi.Pointer<realm_value_t>,
              ffi.Pointer<ffi.Size>,
              ffi.Pointer<ffi.Bool>)>>('realm_dictionary_get_changed_keys');
  late final _realm_dictionary_get_changed_keys =
      _realm_dictionary_get_changed_keysPtr.asFunction<
          void Function(
              ffi.Pointer<realm_dictionary_changes_t>,
              ffi.Pointer<realm_value_t>,
              ffi.Pointer<ffi.Size>,
              ffi.Pointer<realm_value_t>,
              ffi.Pointer<ffi.Size>,
              ffi.Pointer<realm_value_t>,
              ffi.Pointer<ffi.Size>,
              ffi.Pointer<ffi.Bool>)>();

  /// Returns the number of changes occurred to the dictionary passed as argument
  ///
  /// @param changes valid ptr to the dictionary changes structure
  /// @param out_deletions_size number of deletions
  /// @param out_insertion_size number of insertions
  /// @param out_modification_size number of modifications
  /// @param out_was_deleted a flag to signal if the dictionary has been deleted.
  void realm_dictionary_get_changes(
    ffi.Pointer<realm_dictionary_changes_t> changes,
    ffi.Pointer<ffi.Size> out_deletions_size,
    ffi.Pointer<ffi.Size> out_insertion_size,
    ffi.Pointer<ffi.Size> out_modification_size,
    ffi.Pointer<ffi.Bool> out_was_deleted,
  ) {
    return _realm_dictionary_get_changes(
      changes,
      out_deletions_size,
      out_insertion_size,
      out_modification_size,
      out_was_deleted,
    );
  }

  late final _realm_dictionary_get_changesPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<realm_dictionary_changes_t>,
              ffi.Pointer<ffi.Size>,
              ffi.Pointer<ffi.Size>,
              ffi.Pointer<ffi.Size>,
              ffi.Pointer<ffi.Bool>)>>('realm_dictionary_get_changes');
  late final _realm_dictionary_get_changes =
      _realm_dictionary_get_changesPtr.asFunction<
          void Function(
              ffi.Pointer<realm_dictionary_changes_t>,
              ffi.Pointer<ffi.Size>,
              ffi.Pointer<ffi.Size>,
              ffi.Pointer<ffi.Size>,
              ffi.Pointer<ffi.Bool>)>();

  /// Fetch a dictioanry from a dictionary.
  /// @return a valid dictionary that needs to be deleted by the caller or nullptr in case of an error.
  ffi.Pointer<realm_dictionary_t> realm_dictionary_get_dictionary(
    ffi.Pointer<realm_dictionary_t> dictionary,
    realm_value_t key,
  ) {
    return _realm_dictionary_get_dictionary(
      dictionary,
      key,
    );
  }

  late final _realm_dictionary_get_dictionaryPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<realm_dictionary_t> Function(
              ffi.Pointer<realm_dictionary_t>,
              realm_value_t)>>('realm_dictionary_get_dictionary');
  late final _realm_dictionary_get_dictionary =
      _realm_dictionary_get_dictionaryPtr.asFunction<
          ffi.Pointer<realm_dictionary_t> Function(
              ffi.Pointer<realm_dictionary_t>, realm_value_t)>();

  /// Return the list of keys stored in the dictionary
  ///
  /// @param out_size number of keys
  /// @param out_keys the list of keys in the dictionary, the memory has to be released once it is no longer used.
  /// @return True if no exception occurred.
  bool realm_dictionary_get_keys(
    ffi.Pointer<realm_dictionary_t> arg0,
    ffi.Pointer<ffi.Size> out_size,
    ffi.Pointer<ffi.Pointer<realm_results_t>> out_keys,
  ) {
    return _realm_dictionary_get_keys(
      arg0,
      out_size,
      out_keys,
    );
  }

  late final _realm_dictionary_get_keysPtr = _lookup<
          ffi.NativeFunction<
              ffi.Bool Function(
                  ffi.Pointer<realm_dictionary_t>,
                  ffi.Pointer<ffi.Size>,
                  ffi.Pointer<ffi.Pointer<realm_results_t>>)>>(
      'realm_dictionary_get_keys');
  late final _realm_dictionary_get_keys =
      _realm_dictionary_get_keysPtr.asFunction<
          bool Function(ffi.Pointer<realm_dictionary_t>, ffi.Pointer<ffi.Size>,
              ffi.Pointer<ffi.Pointer<realm_results_t>>)>();

  /// Get object identified by key
  ///
  /// @return A non-NULL pointer if the value associated with key is an object.
  ffi.Pointer<realm_object_t> realm_dictionary_get_linked_object(
    ffi.Pointer<realm_dictionary_t> arg0,
    realm_value_t key,
  ) {
    return _realm_dictionary_get_linked_object(
      arg0,
      key,
    );
  }

  late final _realm_dictionary_get_linked_objectPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<realm_object_t> Function(ffi.Pointer<realm_dictionary_t>,
              realm_value_t)>>('realm_dictionary_get_linked_object');
  late final _realm_dictionary_get_linked_object =
      _realm_dictionary_get_linked_objectPtr.asFunction<
          ffi.Pointer<realm_object_t> Function(
              ffi.Pointer<realm_dictionary_t>, realm_value_t)>();

  /// Fetch a list from a dictionary.
  /// @return a valid list that needs to be deleted by the caller or nullptr in case of an error.
  ffi.Pointer<realm_list_t> realm_dictionary_get_list(
    ffi.Pointer<realm_dictionary_t> dictionary,
    realm_value_t key,
  ) {
    return _realm_dictionary_get_list(
      dictionary,
      key,
    );
  }

  late final _realm_dictionary_get_listPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<realm_list_t> Function(ffi.Pointer<realm_dictionary_t>,
              realm_value_t)>>('realm_dictionary_get_list');
  late final _realm_dictionary_get_list =
      _realm_dictionary_get_listPtr.asFunction<
          ffi.Pointer<realm_list_t> Function(
              ffi.Pointer<realm_dictionary_t>, realm_value_t)>();

  /// Get the property that this dictionary came from.
  ///
  /// @return True if no exception occurred.
  bool realm_dictionary_get_property(
    ffi.Pointer<realm_dictionary_t> arg0,
    ffi.Pointer<realm_property_info_t> out_info,
  ) {
    return _realm_dictionary_get_property(
      arg0,
      out_info,
    );
  }

  late final _realm_dictionary_get_propertyPtr = _lookup<
          ffi.NativeFunction<
              ffi.Bool Function(ffi.Pointer<realm_dictionary_t>,
                  ffi.Pointer<realm_property_info_t>)>>(
      'realm_dictionary_get_property');
  late final _realm_dictionary_get_property =
      _realm_dictionary_get_propertyPtr.asFunction<
          bool Function(ffi.Pointer<realm_dictionary_t>,
              ffi.Pointer<realm_property_info_t>)>();

  /// Insert or update an element in a dictionary.
  ///
  /// If the key already exists, the value will be overwritten.
  ///
  /// @param key The lookup key.
  /// @param value The value to insert.
  /// @param out_index If non-null, will be set to the index of the element after
  /// insertion/update.
  /// @param out_inserted If non-null, will be set to true if the key did not
  /// already exist.
  /// @return True if no exception occurred.
  bool realm_dictionary_insert(
    ffi.Pointer<realm_dictionary_t> arg0,
    realm_value_t key,
    realm_value_t value,
    ffi.Pointer<ffi.Size> out_index,
    ffi.Pointer<ffi.Bool> out_inserted,
  ) {
    return _realm_dictionary_insert(
      arg0,
      key,
      value,
      out_index,
      out_inserted,
    );
  }

  late final _realm_dictionary_insertPtr = _lookup<
      ffi.NativeFunction<
          ffi.Bool Function(
              ffi.Pointer<realm_dictionary_t>,
              realm_value_t,
              realm_value_t,
              ffi.Pointer<ffi.Size>,
              ffi.Pointer<ffi.Bool>)>>('realm_dictionary_insert');
  late final _realm_dictionary_insert = _realm_dictionary_insertPtr.asFunction<
      bool Function(ffi.Pointer<realm_dictionary_t>, realm_value_t,
          realm_value_t, ffi.Pointer<ffi.Size>, ffi.Pointer<ffi.Bool>)>();

  ffi.Pointer<realm_dictionary_t> realm_dictionary_insert_dictionary(
    ffi.Pointer<realm_dictionary_t> arg0,
    realm_value_t arg1,
  ) {
    return _realm_dictionary_insert_dictionary(
      arg0,
      arg1,
    );
  }

  late final _realm_dictionary_insert_dictionaryPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<realm_dictionary_t> Function(
              ffi.Pointer<realm_dictionary_t>,
              realm_value_t)>>('realm_dictionary_insert_dictionary');
  late final _realm_dictionary_insert_dictionary =
      _realm_dictionary_insert_dictionaryPtr.asFunction<
          ffi.Pointer<realm_dictionary_t> Function(
              ffi.Pointer<realm_dictionary_t>, realm_value_t)>();

  /// Insert an embedded object.
  ///
  /// @return A non-NULL pointer if the object was created successfully.
  ffi.Pointer<realm_object_t> realm_dictionary_insert_embedded(
    ffi.Pointer<realm_dictionary_t> arg0,
    realm_value_t key,
  ) {
    return _realm_dictionary_insert_embedded(
      arg0,
      key,
    );
  }

  late final _realm_dictionary_insert_embeddedPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<realm_object_t> Function(ffi.Pointer<realm_dictionary_t>,
              realm_value_t)>>('realm_dictionary_insert_embedded');
  late final _realm_dictionary_insert_embedded =
      _realm_dictionary_insert_embeddedPtr.asFunction<
          ffi.Pointer<realm_object_t> Function(
              ffi.Pointer<realm_dictionary_t>, realm_value_t)>();

  /// Insert a collection inside a dictionary (only available for mixed types)
  ///
  /// @param dictionary valid ptr to a dictionary of mixed
  /// @param key the mixed representing a key for a dictionary (only string)
  /// @return pointer to a valid collection that has been just inserted at the key passed as argument
  ffi.Pointer<realm_list_t> realm_dictionary_insert_list(
    ffi.Pointer<realm_dictionary_t> dictionary,
    realm_value_t key,
  ) {
    return _realm_dictionary_insert_list(
      dictionary,
      key,
    );
  }

  late final _realm_dictionary_insert_listPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<realm_list_t> Function(ffi.Pointer<realm_dictionary_t>,
              realm_value_t)>>('realm_dictionary_insert_list');
  late final _realm_dictionary_insert_list =
      _realm_dictionary_insert_listPtr.asFunction<
          ffi.Pointer<realm_list_t> Function(
              ffi.Pointer<realm_dictionary_t>, realm_value_t)>();

  /// Check if a list is valid.
  ///
  /// @return True if the list is valid.
  bool realm_dictionary_is_valid(
    ffi.Pointer<realm_dictionary_t> arg0,
  ) {
    return _realm_dictionary_is_valid(
      arg0,
    );
  }

  late final _realm_dictionary_is_validPtr = _lookup<
          ffi
          .NativeFunction<ffi.Bool Function(ffi.Pointer<realm_dictionary_t>)>>(
      'realm_dictionary_is_valid');
  late final _realm_dictionary_is_valid = _realm_dictionary_is_validPtr
      .asFunction<bool Function(ffi.Pointer<realm_dictionary_t>)>();

  /// Resolve the list in the context of a given Realm instance.
  ///
  /// This is equivalent to producing a thread-safe reference and resolving it in the frozen realm.
  ///
  /// If resolution is possible, a valid resolved object is produced at '*resolved*'.
  /// If resolution is not possible, but no error occurs, '*resolved' is set to NULL
  ///
  /// @return true if no error occurred.
  bool realm_dictionary_resolve_in(
    ffi.Pointer<realm_dictionary_t> list,
    ffi.Pointer<realm_t> target_realm,
    ffi.Pointer<ffi.Pointer<realm_dictionary_t>> resolved,
  ) {
    return _realm_dictionary_resolve_in(
      list,
      target_realm,
      resolved,
    );
  }

  late final _realm_dictionary_resolve_inPtr = _lookup<
          ffi.NativeFunction<
              ffi.Bool Function(
                  ffi.Pointer<realm_dictionary_t>,
                  ffi.Pointer<realm_t>,
                  ffi.Pointer<ffi.Pointer<realm_dictionary_t>>)>>(
      'realm_dictionary_resolve_in');
  late final _realm_dictionary_resolve_in =
      _realm_dictionary_resolve_inPtr.asFunction<
          bool Function(ffi.Pointer<realm_dictionary_t>, ffi.Pointer<realm_t>,
              ffi.Pointer<ffi.Pointer<realm_dictionary_t>>)>();

  /// Get the size of a dictionary (the number of unique keys).
  ///
  /// This function may fail if the object owning the dictionary has been deleted.
  ///
  /// @param out_size Where to put the dictionary size. May be NULL.
  /// @return True if no exception occurred.
  bool realm_dictionary_size(
    ffi.Pointer<realm_dictionary_t> arg0,
    ffi.Pointer<ffi.Size> out_size,
  ) {
    return _realm_dictionary_size(
      arg0,
      out_size,
    );
  }

  late final _realm_dictionary_sizePtr = _lookup<
      ffi.NativeFunction<
          ffi.Bool Function(ffi.Pointer<realm_dictionary_t>,
              ffi.Pointer<ffi.Size>)>>('realm_dictionary_size');
  late final _realm_dictionary_size = _realm_dictionary_sizePtr.asFunction<
      bool Function(ffi.Pointer<realm_dictionary_t>, ffi.Pointer<ffi.Size>)>();

  /// Convert a dictionary to results.
  ///
  /// @return A non-null pointer if no exception occurred.
  ffi.Pointer<realm_results_t> realm_dictionary_to_results(
    ffi.Pointer<realm_dictionary_t> arg0,
  ) {
    return _realm_dictionary_to_results(
      arg0,
    );
  }

  late final _realm_dictionary_to_resultsPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<realm_results_t> Function(
              ffi.Pointer<realm_dictionary_t>)>>('realm_dictionary_to_results');
  late final _realm_dictionary_to_results =
      _realm_dictionary_to_resultsPtr.asFunction<
          ffi.Pointer<realm_results_t> Function(
              ffi.Pointer<realm_dictionary_t>)>();

  /// Return true if two API objects refer to the same underlying data. Objects
  /// with different types are never equal.
  ///
  /// Note: This function cannot be used with types that have value semantics, only
  /// opaque types that have object semantics.
  ///
  /// - `realm_t` objects are identical if they represent the same instance (not
  /// just if they represent the same file).
  /// - `realm_schema_t` objects are equal if the represented schemas are equal.
  /// - `realm_config_t` objects are equal if the configurations are equal.
  /// - `realm_object_t` objects are identical if they belong to the same realm
  /// and class, and have the same object key.
  /// - `realm_list_t` and other collection objects are identical if they come
  /// from the same object and property.
  /// - `realm_query_t` objects are never equal.
  /// - `realm_scheduler_t` objects are equal if they represent the same
  /// scheduler.
  /// - Query descriptor objects are equal if they represent equivalent
  /// descriptors.
  /// - `realm_async_error_t` objects are equal if they represent the same
  /// exception instance.
  ///
  /// This function cannot fail.
  bool realm_equals(
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<ffi.Void> arg1,
  ) {
    return _realm_equals(
      arg0,
      arg1,
    );
  }

  late final _realm_equalsPtr = _lookup<
      ffi.NativeFunction<
          ffi.Bool Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>('realm_equals');
  late final _realm_equals = _realm_equalsPtr.asFunction<
      bool Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// Find a by the name of @a name.
  ///
  /// @param name The name of the class.
  /// @param out_found Set to true if the class was found and no error occurred.
  /// Otherwise, false. May not be NULL.
  /// @param out_class_info A pointer to a `realm_class_info_t` that will be
  /// populated with information about the class. May be
  /// NULL.
  /// @return True if no exception occurred.
  bool realm_find_class(
    ffi.Pointer<realm_t> arg0,
    ffi.Pointer<ffi.Char> name,
    ffi.Pointer<ffi.Bool> out_found,
    ffi.Pointer<realm_class_info_t> out_class_info,
  ) {
    return _realm_find_class(
      arg0,
      name,
      out_found,
      out_class_info,
    );
  }

  late final _realm_find_classPtr = _lookup<
      ffi.NativeFunction<
          ffi.Bool Function(
              ffi.Pointer<realm_t>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Bool>,
              ffi.Pointer<realm_class_info_t>)>>('realm_find_class');
  late final _realm_find_class = _realm_find_classPtr.asFunction<
      bool Function(ffi.Pointer<realm_t>, ffi.Pointer<ffi.Char>,
          ffi.Pointer<ffi.Bool>, ffi.Pointer<realm_class_info_t>)>();

  /// Find the primary key property for a class, if it has one.
  ///
  /// @param class_key The table key for this class.
  /// @param out_found Will be set to true if the property was found. May not be
  /// NULL.
  /// @param out_property_info A property to a `realm_property_info_t` that will be
  /// populated with information about the property, if it
  /// was found. May be NULL.
  /// @return True if no exception occurred.
  bool realm_find_primary_key_property(
    ffi.Pointer<realm_t> arg0,
    int class_key,
    ffi.Pointer<ffi.Bool> out_found,
    ffi.Pointer<realm_property_info_t> out_property_info,
  ) {
    return _realm_find_primary_key_property(
      arg0,
      class_key,
      out_found,
      out_property_info,
    );
  }

  late final _realm_find_primary_key_propertyPtr = _lookup<
          ffi.NativeFunction<
              ffi.Bool Function(ffi.Pointer<realm_t>, realm_class_key_t,
                  ffi.Pointer<ffi.Bool>, ffi.Pointer<realm_property_info_t>)>>(
      'realm_find_primary_key_property');
  late final _realm_find_primary_key_property =
      _realm_find_primary_key_propertyPtr.asFunction<
          bool Function(ffi.Pointer<realm_t>, int, ffi.Pointer<ffi.Bool>,
              ffi.Pointer<realm_property_info_t>)>();

  /// Find a property by the internal (non-public) name of @a name.
  ///
  /// @param class_key The table key for the class.
  /// @param name The name of the property.
  /// @param out_found Will be set to true if the property was found. May not be
  /// NULL.
  /// @param out_property_info A pointer to a `realm_property_info_t` that will be
  /// populated with information about the property. May
  /// be NULL.
  /// @return True if no exception occurred.
  bool realm_find_property(
    ffi.Pointer<realm_t> arg0,
    int class_key,
    ffi.Pointer<ffi.Char> name,
    ffi.Pointer<ffi.Bool> out_found,
    ffi.Pointer<realm_property_info_t> out_property_info,
  ) {
    return _realm_find_property(
      arg0,
      class_key,
      name,
      out_found,
      out_property_info,
    );
  }

  late final _realm_find_propertyPtr = _lookup<
      ffi.NativeFunction<
          ffi.Bool Function(
              ffi.Pointer<realm_t>,
              realm_class_key_t,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Bool>,
              ffi.Pointer<realm_property_info_t>)>>('realm_find_property');
  late final _realm_find_property = _realm_find_propertyPtr.asFunction<
      bool Function(ffi.Pointer<realm_t>, int, ffi.Pointer<ffi.Char>,
          ffi.Pointer<ffi.Bool>, ffi.Pointer<realm_property_info_t>)>();

  /// Find a property with the public name of @a name.
  ///
  /// @param class_key The table key for the class.
  /// @param public_name The public name of the property.
  /// @param out_found Will be set to true if the property was found. May not be
  /// NULL.
  /// @param out_property_info A pointer to a `realm_property_info_t` that will be
  /// populated with information about the property. May
  /// be NULL.
  /// @return True if no exception occurred.
  bool realm_find_property_by_public_name(
    ffi.Pointer<realm_t> arg0,
    int class_key,
    ffi.Pointer<ffi.Char> public_name,
    ffi.Pointer<ffi.Bool> out_found,
    ffi.Pointer<realm_property_info_t> out_property_info,
  ) {
    return _realm_find_property_by_public_name(
      arg0,
      class_key,
      public_name,
      out_found,
      out_property_info,
    );
  }

  late final _realm_find_property_by_public_namePtr = _lookup<
          ffi.NativeFunction<
              ffi.Bool Function(
                  ffi.Pointer<realm_t>,
                  realm_class_key_t,
                  ffi.Pointer<ffi.Char>,
                  ffi.Pointer<ffi.Bool>,
                  ffi.Pointer<realm_property_info_t>)>>(
      'realm_find_property_by_public_name');
  late final _realm_find_property_by_public_name =
      _realm_find_property_by_public_namePtr.asFunction<
          bool Function(ffi.Pointer<realm_t>, int, ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Bool>, ffi.Pointer<realm_property_info_t>)>();

  /// Free memory allocated by the module this library was linked into.
  ///
  /// This is needed for raw memory buffers such as string copies or arrays
  /// returned from a library function. Realm C Wrapper objects on the other hand
  /// should always be freed with realm_release() only.
  void realm_free(
    ffi.Pointer<ffi.Void> buffer,
  ) {
    return _realm_free(
      buffer,
    );
  }

  late final _realm_freePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>(
          'realm_free');
  late final _realm_free =
      _realm_freePtr.asFunction<void Function(ffi.Pointer<ffi.Void>)>();

  /// Produce a frozen view of this realm.
  ///
  /// @return A non-NULL realm instance representing the frozen state.
  ffi.Pointer<realm_t> realm_freeze(
    ffi.Pointer<realm_t> arg0,
  ) {
    return _realm_freeze(
      arg0,
    );
  }

  late final _realm_freezePtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<realm_t> Function(ffi.Pointer<realm_t>)>>('realm_freeze');
  late final _realm_freeze = _realm_freezePtr
      .asFunction<ffi.Pointer<realm_t> Function(ffi.Pointer<realm_t>)>();

  /// Create a `realm_t` object from a thread-safe reference to the same realm.
  ///
  /// @param tsr Thread-safe reference object created by calling
  /// `realm_get_thread_safe_reference()` with a `realm_t` instance.
  /// @param scheduler The scheduler to use for the new `realm_t` instance. May be
  /// NULL, in which case the default scheduler for the current
  /// thread is used.
  /// @return A non-null pointer if no error occurred.
  ffi.Pointer<realm_t> realm_from_thread_safe_reference(
    ffi.Pointer<realm_thread_safe_reference_t> tsr,
    ffi.Pointer<realm_scheduler_t> scheduler,
  ) {
    return _realm_from_thread_safe_reference(
      tsr,
      scheduler,
    );
  }

  late final _realm_from_thread_safe_referencePtr = _lookup<
          ffi.NativeFunction<
              ffi.Pointer<realm_t> Function(
                  ffi.Pointer<realm_thread_safe_reference_t>,
                  ffi.Pointer<realm_scheduler_t>)>>(
      'realm_from_thread_safe_reference');
  late final _realm_from_thread_safe_reference =
      _realm_from_thread_safe_referencePtr.asFunction<
          ffi.Pointer<realm_t> Function(
              ffi.Pointer<realm_thread_safe_reference_t>,
              ffi.Pointer<realm_scheduler_t>)>();

  /// Get information about an async error, potentially coming from another thread.
  ///
  /// This function does not allocate any memory.
  ///
  /// @param err A pointer to a `realm_error_t` struct that will be populated with
  /// information about the error. May not be NULL.
  /// @return A bool indicating whether or not an error is available to be returned
  /// @see realm_get_last_error()
  bool realm_get_async_error(
    ffi.Pointer<realm_async_error_t> err,
    ffi.Pointer<realm_error_t> out_err,
  ) {
    return _realm_get_async_error(
      err,
      out_err,
    );
  }

  late final _realm_get_async_errorPtr = _lookup<
      ffi.NativeFunction<
          ffi.Bool Function(ffi.Pointer<realm_async_error_t>,
              ffi.Pointer<realm_error_t>)>>('realm_get_async_error');
  late final _realm_get_async_error = _realm_get_async_errorPtr.asFunction<
      bool Function(
          ffi.Pointer<realm_async_error_t>, ffi.Pointer<realm_error_t>)>();

  /// Fetch the backlinks for the object passed as argument.
  /// @return a valid ptr to realm results that contains all the backlinks for the object, or null in case of errors.
  ffi.Pointer<realm_results_t> realm_get_backlinks(
    ffi.Pointer<realm_object_t> object,
    int source_table_key,
    int property_key,
  ) {
    return _realm_get_backlinks(
      object,
      source_table_key,
      property_key,
    );
  }

  late final _realm_get_backlinksPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<realm_results_t> Function(ffi.Pointer<realm_object_t>,
              realm_class_key_t, realm_property_key_t)>>('realm_get_backlinks');
  late final _realm_get_backlinks = _realm_get_backlinksPtr.asFunction<
      ffi.Pointer<realm_results_t> Function(
          ffi.Pointer<realm_object_t>, int, int)>();

  /// Get the actual log category names (currently 15)
  /// @param num_values number of values in the out_values array
  /// @param out_values pointer to an array of size num_values
  /// @return returns the number of categories returned. If num_values is zero, it will
  /// return the total number of categories.
  int realm_get_category_names(
    int num_values,
    ffi.Pointer<ffi.Pointer<ffi.Char>> out_values,
  ) {
    return _realm_get_category_names(
      num_values,
      out_values,
    );
  }

  late final _realm_get_category_namesPtr = _lookup<
      ffi.NativeFunction<
          ffi.Size Function(ffi.Size,
              ffi.Pointer<ffi.Pointer<ffi.Char>>)>>('realm_get_category_names');
  late final _realm_get_category_names = _realm_get_category_namesPtr
      .asFunction<int Function(int, ffi.Pointer<ffi.Pointer<ffi.Char>>)>();

  /// Get the class with @a key from the schema.
  ///
  /// Passing an invalid @a key for this schema is considered an error.
  ///
  /// @param key The key of the class, as discovered by `realm_get_class_keys()`.
  /// @param out_class_info A pointer to a `realm_class_info_t` that will be
  /// populated with the information of the class. May be
  /// NULL, though that's kind of pointless.
  /// @return True if no exception occurred.
  bool realm_get_class(
    ffi.Pointer<realm_t> arg0,
    int key,
    ffi.Pointer<realm_class_info_t> out_class_info,
  ) {
    return _realm_get_class(
      arg0,
      key,
      out_class_info,
    );
  }

  late final _realm_get_classPtr = _lookup<
      ffi.NativeFunction<
          ffi.Bool Function(ffi.Pointer<realm_t>, realm_class_key_t,
              ffi.Pointer<realm_class_info_t>)>>('realm_get_class');
  late final _realm_get_class = _realm_get_classPtr.asFunction<
      bool Function(
          ffi.Pointer<realm_t>, int, ffi.Pointer<realm_class_info_t>)>();

  /// Get the table keys for classes in the schema.
  /// In case of errors this function will return false (errors to be fetched via `realm_get_last_error()`).
  /// If data is not copied the function will return true and set  `out_n` with the capacity needed.
  /// Data is only copied if the input array has enough capacity, otherwise the needed  array capacity will be set.
  ///
  /// @param out_keys An array that will contain the keys of each class in the
  /// schema. Array may be NULL, in this case no data will be copied and `out_n` set if not NULL.
  /// @param max The maximum number of keys to write to `out_keys`.
  /// @param out_n The actual number of classes. May be NULL.
  /// @return True if no exception occurred.
  bool realm_get_class_keys(
    ffi.Pointer<realm_t> arg0,
    ffi.Pointer<realm_class_key_t> out_keys,
    int max,
    ffi.Pointer<ffi.Size> out_n,
  ) {
    return _realm_get_class_keys(
      arg0,
      out_keys,
      max,
      out_n,
    );
  }

  late final _realm_get_class_keysPtr = _lookup<
      ffi.NativeFunction<
          ffi.Bool Function(
              ffi.Pointer<realm_t>,
              ffi.Pointer<realm_class_key_t>,
              ffi.Size,
              ffi.Pointer<ffi.Size>)>>('realm_get_class_keys');
  late final _realm_get_class_keys = _realm_get_class_keysPtr.asFunction<
      bool Function(ffi.Pointer<realm_t>, ffi.Pointer<realm_class_key_t>, int,
          ffi.Pointer<ffi.Size>)>();

  /// Get the list of properties for the class with this @a key.
  /// In case of errors this function will return false (errors to be fetched via `realm_get_last_error()`).
  /// If data is not copied the function will return true and set  `out_n` with the capacity needed.
  /// Data is only copied if the input array has enough capacity, otherwise the needed  array capacity will be set.
  ///
  /// @param out_properties  A pointer to an array of `realm_property_info_t`, which
  /// will be populated with the information about the
  /// properties.  Array may be NULL, in this case no data will be copied and `out_n` set if not
  /// NULL.
  /// @param max The maximum number of entries to write to `out_properties`.
  /// @param out_n The actual number of properties written to `out_properties`.
  /// @return True if no exception occurred.
  bool realm_get_class_properties(
    ffi.Pointer<realm_t> arg0,
    int key,
    ffi.Pointer<realm_property_info_t> out_properties,
    int max,
    ffi.Pointer<ffi.Size> out_n,
  ) {
    return _realm_get_class_properties(
      arg0,
      key,
      out_properties,
      max,
      out_n,
    );
  }

  late final _realm_get_class_propertiesPtr = _lookup<
      ffi.NativeFunction<
          ffi.Bool Function(
              ffi.Pointer<realm_t>,
              realm_class_key_t,
              ffi.Pointer<realm_property_info_t>,
              ffi.Size,
              ffi.Pointer<ffi.Size>)>>('realm_get_class_properties');
  late final _realm_get_class_properties =
      _realm_get_class_propertiesPtr.asFunction<
          bool Function(
              ffi.Pointer<realm_t>,
              int,
              ffi.Pointer<realm_property_info_t>,
              int,
              ffi.Pointer<ffi.Size>)>();

  /// Get a dictionary instance for the property of an object.
  ///
  /// Note: It is up to the caller to call `realm_release()` on the returned dictionary.
  ///
  /// @return A non-null pointer if no exception occurred.
  ffi.Pointer<realm_dictionary_t> realm_get_dictionary(
    ffi.Pointer<realm_object_t> arg0,
    int arg1,
  ) {
    return _realm_get_dictionary(
      arg0,
      arg1,
    );
  }

  late final _realm_get_dictionaryPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<realm_dictionary_t> Function(ffi.Pointer<realm_object_t>,
              realm_property_key_t)>>('realm_get_dictionary');
  late final _realm_get_dictionary = _realm_get_dictionaryPtr.asFunction<
      ffi.Pointer<realm_dictionary_t> Function(
          ffi.Pointer<realm_object_t>, int)>();

  /// Get the last error that happened on this thread.
  ///
  /// Errors are thread-local. Getting the error must happen on the same thread as
  /// the call that caused the error to occur. The error is specific to the current
  /// thread, and not the Realm instance for which the error occurred.
  ///
  /// Note: The error message in @a err will only be safe to use until the next API
  /// call is made on the current thread.
  ///
  /// Note: The error is not cleared by subsequent successful calls to this
  /// function, but it will be overwritten by subsequent failing calls to
  /// other library functions.
  ///
  /// Note: Calling this function does not clear the current last error.
  ///
  /// This function does not allocate any memory.
  ///
  /// @param err A pointer to a `realm_error_t` struct that will be populated with
  /// information about the last error, if there is one. May be NULL.
  /// @return True if an error occurred.
  bool realm_get_last_error(
    ffi.Pointer<realm_error_t> err,
  ) {
    return _realm_get_last_error(
      err,
    );
  }

  late final _realm_get_last_errorPtr = _lookup<
          ffi.NativeFunction<ffi.Bool Function(ffi.Pointer<realm_error_t>)>>(
      'realm_get_last_error');
  late final _realm_get_last_error = _realm_get_last_errorPtr
      .asFunction<bool Function(ffi.Pointer<realm_error_t>)>();

  /// Convert the last error to `realm_async_error_t`, which can safely be passed
  /// between threads.
  ///
  /// Note: This function does not clear the last error.
  ///
  /// @return A non-null pointer if there was an error on this thread.
  /// @see realm_get_last_error()
  /// @see realm_get_async_error()
  /// @see realm_clear_last_error()
  ffi.Pointer<realm_async_error_t> realm_get_last_error_as_async_error() {
    return _realm_get_last_error_as_async_error();
  }

  late final _realm_get_last_error_as_async_errorPtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<realm_async_error_t> Function()>>(
          'realm_get_last_error_as_async_error');
  late final _realm_get_last_error_as_async_error =
      _realm_get_last_error_as_async_errorPtr
          .asFunction<ffi.Pointer<realm_async_error_t> Function()>();

  ffi.Pointer<ffi.Char> realm_get_library_cpu_arch() {
    return _realm_get_library_cpu_arch();
  }

  late final _realm_get_library_cpu_archPtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Char> Function()>>(
          'realm_get_library_cpu_arch');
  late final _realm_get_library_cpu_arch = _realm_get_library_cpu_archPtr
      .asFunction<ffi.Pointer<ffi.Char> Function()>();

  /// Get a string representing the version number of the Realm library.
  ///
  /// @return A null-terminated string.
  ffi.Pointer<ffi.Char> realm_get_library_version() {
    return _realm_get_library_version();
  }

  late final _realm_get_library_versionPtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Char> Function()>>(
          'realm_get_library_version');
  late final _realm_get_library_version = _realm_get_library_versionPtr
      .asFunction<ffi.Pointer<ffi.Char> Function()>();

  /// Get individual components of the version number of the Realm library.
  ///
  /// @param out_major The major version number (X.0.0).
  /// @param out_minor The minor version number (0.X.0).
  /// @param out_patch The patch version number (0.0.X).
  /// @param out_extra The extra version string (0.0.0-X).
  void realm_get_library_version_numbers(
    ffi.Pointer<ffi.Int> out_major,
    ffi.Pointer<ffi.Int> out_minor,
    ffi.Pointer<ffi.Int> out_patch,
    ffi.Pointer<ffi.Pointer<ffi.Char>> out_extra,
  ) {
    return _realm_get_library_version_numbers(
      out_major,
      out_minor,
      out_patch,
      out_extra,
    );
  }

  late final _realm_get_library_version_numbersPtr = _lookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<ffi.Int>, ffi.Pointer<ffi.Int>,
                  ffi.Pointer<ffi.Int>, ffi.Pointer<ffi.Pointer<ffi.Char>>)>>(
      'realm_get_library_version_numbers');
  late final _realm_get_library_version_numbers =
      _realm_get_library_version_numbersPtr.asFunction<
          void Function(ffi.Pointer<ffi.Int>, ffi.Pointer<ffi.Int>,
              ffi.Pointer<ffi.Int>, ffi.Pointer<ffi.Pointer<ffi.Char>>)>();

  /// Return the object linked by the given property
  ///
  /// @return A non-NULL pointer if an object is found.
  ffi.Pointer<realm_object_t> realm_get_linked_object(
    ffi.Pointer<realm_object_t> arg0,
    int arg1,
  ) {
    return _realm_get_linked_object(
      arg0,
      arg1,
    );
  }

  late final _realm_get_linked_objectPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<realm_object_t> Function(ffi.Pointer<realm_object_t>,
              realm_property_key_t)>>('realm_get_linked_object');
  late final _realm_get_linked_object = _realm_get_linked_objectPtr.asFunction<
      ffi.Pointer<realm_object_t> Function(ffi.Pointer<realm_object_t>, int)>();

  /// Get a list instance for the property of an object.
  ///
  /// Note: It is up to the caller to call `realm_release()` on the returned list.
  ///
  /// @return A non-null pointer if no exception occurred.
  ffi.Pointer<realm_list_t> realm_get_list(
    ffi.Pointer<realm_object_t> arg0,
    int arg1,
  ) {
    return _realm_get_list(
      arg0,
      arg1,
    );
  }

  late final _realm_get_listPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<realm_list_t> Function(ffi.Pointer<realm_object_t>,
              realm_property_key_t)>>('realm_get_list');
  late final _realm_get_list = _realm_get_listPtr.asFunction<
      ffi.Pointer<realm_list_t> Function(ffi.Pointer<realm_object_t>, int)>();

  /// Get the logging level for given category.
  realm_log_level realm_get_log_level_category(
    ffi.Pointer<ffi.Char> arg0,
  ) {
    return realm_log_level.fromValue(_realm_get_log_level_category(
      arg0,
    ));
  }

  late final _realm_get_log_level_categoryPtr = _lookup<
          ffi.NativeFunction<ffi.UnsignedInt Function(ffi.Pointer<ffi.Char>)>>(
      'realm_get_log_level_category');
  late final _realm_get_log_level_category = _realm_get_log_level_categoryPtr
      .asFunction<int Function(ffi.Pointer<ffi.Char>)>();

  /// Return the number of classes in the Realm's schema.
  ///
  /// This cannot fail.
  int realm_get_num_classes(
    ffi.Pointer<realm_t> arg0,
  ) {
    return _realm_get_num_classes(
      arg0,
    );
  }

  late final _realm_get_num_classesPtr =
      _lookup<ffi.NativeFunction<ffi.Size Function(ffi.Pointer<realm_t>)>>(
          'realm_get_num_classes');
  late final _realm_get_num_classes = _realm_get_num_classesPtr
      .asFunction<int Function(ffi.Pointer<realm_t>)>();

  /// Get the number of objects in a table (class).
  ///
  /// @param out_count A pointer to a `size_t` that will contain the number of
  /// objects, if successful.
  /// @return True if the table key was valid for this realm.
  bool realm_get_num_objects(
    ffi.Pointer<realm_t> arg0,
    int arg1,
    ffi.Pointer<ffi.Size> out_count,
  ) {
    return _realm_get_num_objects(
      arg0,
      arg1,
      out_count,
    );
  }

  late final _realm_get_num_objectsPtr = _lookup<
      ffi.NativeFunction<
          ffi.Bool Function(ffi.Pointer<realm_t>, realm_class_key_t,
              ffi.Pointer<ffi.Size>)>>('realm_get_num_objects');
  late final _realm_get_num_objects = _realm_get_num_objectsPtr.asFunction<
      bool Function(ffi.Pointer<realm_t>, int, ffi.Pointer<ffi.Size>)>();

  /// Get the number of versions found in the Realm file.
  ///
  /// @param out_versions_count A pointer to a `size_t` that will contain the number of
  /// versions, if successful.
  /// @return True if no exception occurred.
  bool realm_get_num_versions(
    ffi.Pointer<realm_t> arg0,
    ffi.Pointer<ffi.Uint64> out_versions_count,
  ) {
    return _realm_get_num_versions(
      arg0,
      out_versions_count,
    );
  }

  late final _realm_get_num_versionsPtr = _lookup<
      ffi.NativeFunction<
          ffi.Bool Function(ffi.Pointer<realm_t>,
              ffi.Pointer<ffi.Uint64>)>>('realm_get_num_versions');
  late final _realm_get_num_versions = _realm_get_num_versionsPtr.asFunction<
      bool Function(ffi.Pointer<realm_t>, ffi.Pointer<ffi.Uint64>)>();

  /// Get an object with a particular object key.
  ///
  /// @param class_key The class key.
  /// @param obj_key The key to the object. Passing a non-existent key is
  /// considered an error.
  /// @return A non-NULL pointer if no exception occurred.
  ffi.Pointer<realm_object_t> realm_get_object(
    ffi.Pointer<realm_t> arg0,
    int class_key,
    int obj_key,
  ) {
    return _realm_get_object(
      arg0,
      class_key,
      obj_key,
    );
  }

  late final _realm_get_objectPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<realm_object_t> Function(ffi.Pointer<realm_t>,
              realm_class_key_t, realm_object_key_t)>>('realm_get_object');
  late final _realm_get_object = _realm_get_objectPtr.asFunction<
      ffi.Pointer<realm_object_t> Function(ffi.Pointer<realm_t>, int, int)>();

  /// Get the schema version for this realm at the path.
  int realm_get_persisted_schema_version(
    ffi.Pointer<realm_config_t> config,
  ) {
    return _realm_get_persisted_schema_version(
      config,
    );
  }

  late final _realm_get_persisted_schema_versionPtr = _lookup<
          ffi.NativeFunction<ffi.Uint64 Function(ffi.Pointer<realm_config_t>)>>(
      'realm_get_persisted_schema_version');
  late final _realm_get_persisted_schema_version =
      _realm_get_persisted_schema_versionPtr
          .asFunction<int Function(ffi.Pointer<realm_config_t>)>();

  /// Find a property by its column key.
  ///
  /// It is an error to pass a property @a key that is not present in this class.
  ///
  /// @param class_key The key of the class.
  /// @param key The column key for the property.
  /// @param out_property_info A pointer to a `realm_property_info_t` that will be
  /// populated with information about the property.
  /// @return True if no exception occurred.
  bool realm_get_property(
    ffi.Pointer<realm_t> arg0,
    int class_key,
    int key,
    ffi.Pointer<realm_property_info_t> out_property_info,
  ) {
    return _realm_get_property(
      arg0,
      class_key,
      key,
      out_property_info,
    );
  }

  late final _realm_get_propertyPtr = _lookup<
      ffi.NativeFunction<
          ffi.Bool Function(
              ffi.Pointer<realm_t>,
              realm_class_key_t,
              realm_property_key_t,
              ffi.Pointer<realm_property_info_t>)>>('realm_get_property');
  late final _realm_get_property = _realm_get_propertyPtr.asFunction<
      bool Function(ffi.Pointer<realm_t>, int, int,
          ffi.Pointer<realm_property_info_t>)>();

  /// Get the property keys for the class with this @a key.
  /// In case of errors this function will return false (errors to be fetched via `realm_get_last_error()`).
  /// If data is not copied the function will return true and set  `out_n` with the capacity needed.
  /// Data is only copied if the input array has enough capacity, otherwise the needed  array capacity will be set.
  ///
  /// @param key The class key.
  /// @param out_col_keys An array of property keys. Array may be NULL,
  /// in this case no data will be copied and `out_n` set if not NULL.
  /// @param max The maximum number of keys to write to `out_col_keys`. Ignored if
  /// `out_col_keys == NULL`.
  /// @param out_n The actual number of properties written to `out_col_keys` (if
  /// non-NULL), or number of properties in the class.
  /// @return True if no exception occurred.
  bool realm_get_property_keys(
    ffi.Pointer<realm_t> arg0,
    int key,
    ffi.Pointer<realm_property_key_t> out_col_keys,
    int max,
    ffi.Pointer<ffi.Size> out_n,
  ) {
    return _realm_get_property_keys(
      arg0,
      key,
      out_col_keys,
      max,
      out_n,
    );
  }

  late final _realm_get_property_keysPtr = _lookup<
      ffi.NativeFunction<
          ffi.Bool Function(
              ffi.Pointer<realm_t>,
              realm_class_key_t,
              ffi.Pointer<realm_property_key_t>,
              ffi.Size,
              ffi.Pointer<ffi.Size>)>>('realm_get_property_keys');
  late final _realm_get_property_keys = _realm_get_property_keysPtr.asFunction<
      bool Function(ffi.Pointer<realm_t>, int,
          ffi.Pointer<realm_property_key_t>, int, ffi.Pointer<ffi.Size>)>();

  /// Get the schema for this realm.
  ///
  /// Note: The returned value is allocated by this function, so `realm_release()`
  /// must be called on it.
  ffi.Pointer<realm_schema_t> realm_get_schema(
    ffi.Pointer<realm_t> arg0,
  ) {
    return _realm_get_schema(
      arg0,
    );
  }

  late final _realm_get_schemaPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<realm_schema_t> Function(
              ffi.Pointer<realm_t>)>>('realm_get_schema');
  late final _realm_get_schema = _realm_get_schemaPtr
      .asFunction<ffi.Pointer<realm_schema_t> Function(ffi.Pointer<realm_t>)>();

  /// Get the schema version for this realm.
  ///
  /// This function cannot fail.
  int realm_get_schema_version(
    ffi.Pointer<realm_t> realm,
  ) {
    return _realm_get_schema_version(
      realm,
    );
  }

  late final _realm_get_schema_versionPtr =
      _lookup<ffi.NativeFunction<ffi.Uint64 Function(ffi.Pointer<realm_t>)>>(
          'realm_get_schema_version');
  late final _realm_get_schema_version = _realm_get_schema_versionPtr
      .asFunction<int Function(ffi.Pointer<realm_t>)>();

  /// Get a set instance for the property of an object.
  ///
  /// Note: It is up to the caller to call `realm_release()` on the returned set.
  ///
  /// @return A non-null pointer if no exception occurred.
  ffi.Pointer<realm_set_t> realm_get_set(
    ffi.Pointer<realm_object_t> arg0,
    int arg1,
  ) {
    return _realm_get_set(
      arg0,
      arg1,
    );
  }

  late final _realm_get_setPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<realm_set_t> Function(ffi.Pointer<realm_object_t>,
              realm_property_key_t)>>('realm_get_set');
  late final _realm_get_set = _realm_get_setPtr.asFunction<
      ffi.Pointer<realm_set_t> Function(ffi.Pointer<realm_object_t>, int)>();

  /// Get the value for a property.
  ///
  /// @return True if no exception occurred.
  bool realm_get_value(
    ffi.Pointer<realm_object_t> arg0,
    int arg1,
    ffi.Pointer<realm_value_t> out_value,
  ) {
    return _realm_get_value(
      arg0,
      arg1,
      out_value,
    );
  }

  late final _realm_get_valuePtr = _lookup<
      ffi.NativeFunction<
          ffi.Bool Function(ffi.Pointer<realm_object_t>, realm_property_key_t,
              ffi.Pointer<realm_value_t>)>>('realm_get_value');
  late final _realm_get_value = _realm_get_valuePtr.asFunction<
      bool Function(
          ffi.Pointer<realm_object_t>, int, ffi.Pointer<realm_value_t>)>();

  /// Get the value for the property at the specified index in the object's schema.
  /// @param prop_index The index of the property in the class properties array the realm was opened with.
  /// @return True if no exception occurred.
  bool realm_get_value_by_property_index(
    ffi.Pointer<realm_object_t> object,
    int prop_index,
    ffi.Pointer<realm_value_t> out_value,
  ) {
    return _realm_get_value_by_property_index(
      object,
      prop_index,
      out_value,
    );
  }

  late final _realm_get_value_by_property_indexPtr = _lookup<
          ffi.NativeFunction<
              ffi.Bool Function(ffi.Pointer<realm_object_t>, ffi.Size,
                  ffi.Pointer<realm_value_t>)>>(
      'realm_get_value_by_property_index');
  late final _realm_get_value_by_property_index =
      _realm_get_value_by_property_indexPtr.asFunction<
          bool Function(
              ffi.Pointer<realm_object_t>, int, ffi.Pointer<realm_value_t>)>();

  /// Get the values for several properties.
  ///
  /// This is provided as an alternative to calling `realm_get_value()` multiple
  /// times in a row, which is particularly useful for language runtimes where
  /// crossing the native bridge is comparatively expensive. In addition, it
  /// eliminates some parameter validation that would otherwise be repeated for
  /// each call.
  ///
  /// Example use cases:
  ///
  /// - Extracting all properties of an object for serialization.
  /// - Converting an object to some in-memory representation.
  ///
  /// @param num_values The number of elements in @a properties and @a out_values.
  /// @param properties The keys for the properties to fetch. May not be NULL.
  /// @param out_values Where to write the property values. If an error occurs,
  /// this array may only be partially initialized. May not be
  /// NULL.
  /// @return True if no exception occurs.
  bool realm_get_values(
    ffi.Pointer<realm_object_t> arg0,
    int num_values,
    ffi.Pointer<realm_property_key_t> properties,
    ffi.Pointer<realm_value_t> out_values,
  ) {
    return _realm_get_values(
      arg0,
      num_values,
      properties,
      out_values,
    );
  }

  late final _realm_get_valuesPtr = _lookup<
      ffi.NativeFunction<
          ffi.Bool Function(
              ffi.Pointer<realm_object_t>,
              ffi.Size,
              ffi.Pointer<realm_property_key_t>,
              ffi.Pointer<realm_value_t>)>>('realm_get_values');
  late final _realm_get_values = _realm_get_valuesPtr.asFunction<
      bool Function(ffi.Pointer<realm_object_t>, int,
          ffi.Pointer<realm_property_key_t>, ffi.Pointer<realm_value_t>)>();

  /// Get the VersionID of the current transaction.
  ///
  /// @param out_found True if version information is available. This requires an available Read or Write transaction.
  /// @param out_version The version of the current transaction. If `out_found` returns False, this returns (0,0).
  /// @return True if no exception occurred.
  bool realm_get_version_id(
    ffi.Pointer<realm_t> arg0,
    ffi.Pointer<ffi.Bool> out_found,
    ffi.Pointer<realm_version_id_t> out_version,
  ) {
    return _realm_get_version_id(
      arg0,
      out_found,
      out_version,
    );
  }

  late final _realm_get_version_idPtr = _lookup<
      ffi.NativeFunction<
          ffi.Bool Function(ffi.Pointer<realm_t>, ffi.Pointer<ffi.Bool>,
              ffi.Pointer<realm_version_id_t>)>>('realm_get_version_id');
  late final _realm_get_version_id = _realm_get_version_idPtr.asFunction<
      bool Function(ffi.Pointer<realm_t>, ffi.Pointer<ffi.Bool>,
          ffi.Pointer<realm_version_id_t>)>();

  /// True if the Realm file is closed.
  ///
  /// This function cannot fail.
  bool realm_is_closed(
    ffi.Pointer<realm_t> arg0,
  ) {
    return _realm_is_closed(
      arg0,
    );
  }

  late final _realm_is_closedPtr =
      _lookup<ffi.NativeFunction<ffi.Bool Function(ffi.Pointer<realm_t>)>>(
          'realm_is_closed');
  late final _realm_is_closed =
      _realm_is_closedPtr.asFunction<bool Function(ffi.Pointer<realm_t>)>();

  /// True if a Realm C Wrapper object is "frozen" (immutable).
  ///
  /// Objects, collections, and results can be frozen. For all other types, this
  /// function always returns false.
  bool realm_is_frozen(
    ffi.Pointer<ffi.Void> arg0,
  ) {
    return _realm_is_frozen(
      arg0,
    );
  }

  late final _realm_is_frozenPtr =
      _lookup<ffi.NativeFunction<ffi.Bool Function(ffi.Pointer<ffi.Void>)>>(
          'realm_is_frozen');
  late final _realm_is_frozen =
      _realm_is_frozenPtr.asFunction<bool Function(ffi.Pointer<ffi.Void>)>();

  /// Return true if the realm is in a write transaction.
  ///
  /// This function cannot fail.
  bool realm_is_writable(
    ffi.Pointer<realm_t> arg0,
  ) {
    return _realm_is_writable(
      arg0,
    );
  }

  late final _realm_is_writablePtr =
      _lookup<ffi.NativeFunction<ffi.Bool Function(ffi.Pointer<realm_t>)>>(
          'realm_is_writable');
  late final _realm_is_writable =
      _realm_is_writablePtr.asFunction<bool Function(ffi.Pointer<realm_t>)>();

  /// Subscribe to notifications for this object.
  ///
  /// @return A non-null pointer if no exception occurred.
  ffi.Pointer<realm_notification_token_t> realm_list_add_notification_callback(
    ffi.Pointer<realm_list_t> arg0,
    ffi.Pointer<ffi.Void> userdata,
    realm_free_userdata_func_t userdata_free,
    ffi.Pointer<realm_key_path_array_t> key_path_array,
    realm_on_collection_change_func_t on_change,
  ) {
    return _realm_list_add_notification_callback(
      arg0,
      userdata,
      userdata_free,
      key_path_array,
      on_change,
    );
  }

  late final _realm_list_add_notification_callbackPtr = _lookup<
          ffi.NativeFunction<
              ffi.Pointer<realm_notification_token_t> Function(
                  ffi.Pointer<realm_list_t>,
                  ffi.Pointer<ffi.Void>,
                  realm_free_userdata_func_t,
                  ffi.Pointer<realm_key_path_array_t>,
                  realm_on_collection_change_func_t)>>(
      'realm_list_add_notification_callback');
  late final _realm_list_add_notification_callback =
      _realm_list_add_notification_callbackPtr.asFunction<
          ffi.Pointer<realm_notification_token_t> Function(
              ffi.Pointer<realm_list_t>,
              ffi.Pointer<ffi.Void>,
              realm_free_userdata_func_t,
              ffi.Pointer<realm_key_path_array_t>,
              realm_on_collection_change_func_t)>();

  /// Clear a list, removing all elements in the list. In a list of links, this
  /// does *NOT* delete the target objects.
  ///
  /// @return True if no exception occurred.
  bool realm_list_clear(
    ffi.Pointer<realm_list_t> arg0,
  ) {
    return _realm_list_clear(
      arg0,
    );
  }

  late final _realm_list_clearPtr =
      _lookup<ffi.NativeFunction<ffi.Bool Function(ffi.Pointer<realm_list_t>)>>(
          'realm_list_clear');
  late final _realm_list_clear = _realm_list_clearPtr
      .asFunction<bool Function(ffi.Pointer<realm_list_t>)>();

  /// Erase the element at @a index.
  ///
  /// @return True if no exception occurred.
  bool realm_list_erase(
    ffi.Pointer<realm_list_t> arg0,
    int index,
  ) {
    return _realm_list_erase(
      arg0,
      index,
    );
  }

  late final _realm_list_erasePtr = _lookup<
      ffi.NativeFunction<
          ffi.Bool Function(
              ffi.Pointer<realm_list_t>, ffi.Size)>>('realm_list_erase');
  late final _realm_list_erase = _realm_list_erasePtr
      .asFunction<bool Function(ffi.Pointer<realm_list_t>, int)>();

  /// Find the value in the list passed as parameter.
  /// @param value to search in the list
  /// @param out_index the index in the list where the value has been found or realm::not_found.
  /// @param out_found boolean that indicates whether the value is found or not
  /// @return true if no exception occurred.
  bool realm_list_find(
    ffi.Pointer<realm_list_t> arg0,
    ffi.Pointer<realm_value_t> value,
    ffi.Pointer<ffi.Size> out_index,
    ffi.Pointer<ffi.Bool> out_found,
  ) {
    return _realm_list_find(
      arg0,
      value,
      out_index,
      out_found,
    );
  }

  late final _realm_list_findPtr = _lookup<
      ffi.NativeFunction<
          ffi.Bool Function(
              ffi.Pointer<realm_list_t>,
              ffi.Pointer<realm_value_t>,
              ffi.Pointer<ffi.Size>,
              ffi.Pointer<ffi.Bool>)>>('realm_list_find');
  late final _realm_list_find = _realm_list_findPtr.asFunction<
      bool Function(ffi.Pointer<realm_list_t>, ffi.Pointer<realm_value_t>,
          ffi.Pointer<ffi.Size>, ffi.Pointer<ffi.Bool>)>();

  /// Get an list from a thread-safe reference, potentially originating in a
  /// different `realm_t` instance
  ffi.Pointer<realm_list_t> realm_list_from_thread_safe_reference(
    ffi.Pointer<realm_t> arg0,
    ffi.Pointer<realm_thread_safe_reference_t> arg1,
  ) {
    return _realm_list_from_thread_safe_reference(
      arg0,
      arg1,
    );
  }

  late final _realm_list_from_thread_safe_referencePtr = _lookup<
          ffi.NativeFunction<
              ffi.Pointer<realm_list_t> Function(ffi.Pointer<realm_t>,
                  ffi.Pointer<realm_thread_safe_reference_t>)>>(
      'realm_list_from_thread_safe_reference');
  late final _realm_list_from_thread_safe_reference =
      _realm_list_from_thread_safe_referencePtr.asFunction<
          ffi.Pointer<realm_list_t> Function(ffi.Pointer<realm_t>,
              ffi.Pointer<realm_thread_safe_reference_t>)>();

  /// Get the value at @a index.
  ///
  /// @param out_value The resulting value, if no error occurred. May be NULL,
  /// though nonsensical.
  /// @return True if no exception occurred.
  bool realm_list_get(
    ffi.Pointer<realm_list_t> arg0,
    int index,
    ffi.Pointer<realm_value_t> out_value,
  ) {
    return _realm_list_get(
      arg0,
      index,
      out_value,
    );
  }

  late final _realm_list_getPtr = _lookup<
      ffi.NativeFunction<
          ffi.Bool Function(ffi.Pointer<realm_list_t>, ffi.Size,
              ffi.Pointer<realm_value_t>)>>('realm_list_get');
  late final _realm_list_get = _realm_list_getPtr.asFunction<
      bool Function(
          ffi.Pointer<realm_list_t>, int, ffi.Pointer<realm_value_t>)>();

  /// Returns a nested dictionary if such collection exists, NULL otherwise.
  ///
  /// @param list pointer to the list that containes the nested collection into
  /// @param index position of collection in the list
  /// @return a pointer to the the nested dictionary found at index passed as argument
  ffi.Pointer<realm_dictionary_t> realm_list_get_dictionary(
    ffi.Pointer<realm_list_t> list,
    int index,
  ) {
    return _realm_list_get_dictionary(
      list,
      index,
    );
  }

  late final _realm_list_get_dictionaryPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<realm_dictionary_t> Function(ffi.Pointer<realm_list_t>,
              ffi.Size)>>('realm_list_get_dictionary');
  late final _realm_list_get_dictionary =
      _realm_list_get_dictionaryPtr.asFunction<
          ffi.Pointer<realm_dictionary_t> Function(
              ffi.Pointer<realm_list_t>, int)>();

  /// Get object identified at index
  ///
  /// @return A non-NULL pointer if value is an object.
  ffi.Pointer<realm_object_t> realm_list_get_linked_object(
    ffi.Pointer<realm_list_t> arg0,
    int index,
  ) {
    return _realm_list_get_linked_object(
      arg0,
      index,
    );
  }

  late final _realm_list_get_linked_objectPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<realm_object_t> Function(ffi.Pointer<realm_list_t>,
              ffi.Size)>>('realm_list_get_linked_object');
  late final _realm_list_get_linked_object =
      _realm_list_get_linked_objectPtr.asFunction<
          ffi.Pointer<realm_object_t> Function(
              ffi.Pointer<realm_list_t>, int)>();

  /// Returns a nested list if such collection exists, NULL otherwise.
  ///
  /// @param list pointer to the list that containes the nested list
  /// @param index index of collection in the list
  /// @return a pointer to the the nested list found at the index passed as argument
  ffi.Pointer<realm_list_t> realm_list_get_list(
    ffi.Pointer<realm_list_t> list,
    int index,
  ) {
    return _realm_list_get_list(
      list,
      index,
    );
  }

  late final _realm_list_get_listPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<realm_list_t> Function(
              ffi.Pointer<realm_list_t>, ffi.Size)>>('realm_list_get_list');
  late final _realm_list_get_list = _realm_list_get_listPtr.asFunction<
      ffi.Pointer<realm_list_t> Function(ffi.Pointer<realm_list_t>, int)>();

  /// Get the property that this list came from.
  ///
  /// @return True if no exception occurred.
  bool realm_list_get_property(
    ffi.Pointer<realm_list_t> arg0,
    ffi.Pointer<realm_property_info_t> out_property_info,
  ) {
    return _realm_list_get_property(
      arg0,
      out_property_info,
    );
  }

  late final _realm_list_get_propertyPtr = _lookup<
      ffi.NativeFunction<
          ffi.Bool Function(ffi.Pointer<realm_list_t>,
              ffi.Pointer<realm_property_info_t>)>>('realm_list_get_property');
  late final _realm_list_get_property = _realm_list_get_propertyPtr.asFunction<
      bool Function(
          ffi.Pointer<realm_list_t>, ffi.Pointer<realm_property_info_t>)>();

  /// Insert @a value at @a index.
  ///
  /// @param value The value to insert.
  /// @return True if no exception occurred.
  bool realm_list_insert(
    ffi.Pointer<realm_list_t> arg0,
    int index,
    realm_value_t value,
  ) {
    return _realm_list_insert(
      arg0,
      index,
      value,
    );
  }

  late final _realm_list_insertPtr = _lookup<
      ffi.NativeFunction<
          ffi.Bool Function(ffi.Pointer<realm_list_t>, ffi.Size,
              realm_value_t)>>('realm_list_insert');
  late final _realm_list_insert = _realm_list_insertPtr.asFunction<
      bool Function(ffi.Pointer<realm_list_t>, int, realm_value_t)>();

  ffi.Pointer<realm_dictionary_t> realm_list_insert_dictionary(
    ffi.Pointer<realm_list_t> list,
    int index,
  ) {
    return _realm_list_insert_dictionary(
      list,
      index,
    );
  }

  late final _realm_list_insert_dictionaryPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<realm_dictionary_t> Function(ffi.Pointer<realm_list_t>,
              ffi.Size)>>('realm_list_insert_dictionary');
  late final _realm_list_insert_dictionary =
      _realm_list_insert_dictionaryPtr.asFunction<
          ffi.Pointer<realm_dictionary_t> Function(
              ffi.Pointer<realm_list_t>, int)>();

  /// Insert an embedded object at a given position.
  ///
  /// @return A non-NULL pointer if the object was created successfully.
  ffi.Pointer<realm_object_t> realm_list_insert_embedded(
    ffi.Pointer<realm_list_t> arg0,
    int index,
  ) {
    return _realm_list_insert_embedded(
      arg0,
      index,
    );
  }

  late final _realm_list_insert_embeddedPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<realm_object_t> Function(ffi.Pointer<realm_list_t>,
              ffi.Size)>>('realm_list_insert_embedded');
  late final _realm_list_insert_embedded =
      _realm_list_insert_embeddedPtr.asFunction<
          ffi.Pointer<realm_object_t> Function(
              ffi.Pointer<realm_list_t>, int)>();

  /// Insert a collection inside a list (only available for mixed types)
  ///
  /// @param list valid ptr to a list of mixed
  /// @param index position in the list where to add the collection
  /// @return pointer to a valid collection that has been just inserted at the index passed as argument
  ffi.Pointer<realm_list_t> realm_list_insert_list(
    ffi.Pointer<realm_list_t> list,
    int index,
  ) {
    return _realm_list_insert_list(
      list,
      index,
    );
  }

  late final _realm_list_insert_listPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<realm_list_t> Function(
              ffi.Pointer<realm_list_t>, ffi.Size)>>('realm_list_insert_list');
  late final _realm_list_insert_list = _realm_list_insert_listPtr.asFunction<
      ffi.Pointer<realm_list_t> Function(ffi.Pointer<realm_list_t>, int)>();

  /// Check if a list is valid.
  ///
  /// @return True if the list is valid.
  bool realm_list_is_valid(
    ffi.Pointer<realm_list_t> arg0,
  ) {
    return _realm_list_is_valid(
      arg0,
    );
  }

  late final _realm_list_is_validPtr =
      _lookup<ffi.NativeFunction<ffi.Bool Function(ffi.Pointer<realm_list_t>)>>(
          'realm_list_is_valid');
  late final _realm_list_is_valid = _realm_list_is_validPtr
      .asFunction<bool Function(ffi.Pointer<realm_list_t>)>();

  /// Move the element at @a from_index to @a to_index.
  ///
  /// @param from_index The index of the element to move.
  /// @param to_index The index to move the element to.
  /// @return True if no exception occurred.
  bool realm_list_move(
    ffi.Pointer<realm_list_t> arg0,
    int from_index,
    int to_index,
  ) {
    return _realm_list_move(
      arg0,
      from_index,
      to_index,
    );
  }

  late final _realm_list_movePtr = _lookup<
      ffi.NativeFunction<
          ffi.Bool Function(ffi.Pointer<realm_list_t>, ffi.Size,
              ffi.Size)>>('realm_list_move');
  late final _realm_list_move = _realm_list_movePtr
      .asFunction<bool Function(ffi.Pointer<realm_list_t>, int, int)>();

  /// In a list of objects, delete all objects in the list and clear the list. In a
  /// list of values, clear the list.
  ///
  /// @return True if no exception occurred.
  bool realm_list_remove_all(
    ffi.Pointer<realm_list_t> arg0,
  ) {
    return _realm_list_remove_all(
      arg0,
    );
  }

  late final _realm_list_remove_allPtr =
      _lookup<ffi.NativeFunction<ffi.Bool Function(ffi.Pointer<realm_list_t>)>>(
          'realm_list_remove_all');
  late final _realm_list_remove_all = _realm_list_remove_allPtr
      .asFunction<bool Function(ffi.Pointer<realm_list_t>)>();

  /// Resolve the list in the context of a given Realm instance.
  ///
  /// This is equivalent to producing a thread-safe reference and resolving it in the frozen realm.
  ///
  /// If resolution is possible, a valid resolved object is produced at '*resolved*'.
  /// If resolution is not possible, but no error occurs, '*resolved' is set to NULL
  ///
  /// @return true if no error occurred.
  bool realm_list_resolve_in(
    ffi.Pointer<realm_list_t> list,
    ffi.Pointer<realm_t> target_realm,
    ffi.Pointer<ffi.Pointer<realm_list_t>> resolved,
  ) {
    return _realm_list_resolve_in(
      list,
      target_realm,
      resolved,
    );
  }

  late final _realm_list_resolve_inPtr = _lookup<
          ffi.NativeFunction<
              ffi.Bool Function(ffi.Pointer<realm_list_t>, ffi.Pointer<realm_t>,
                  ffi.Pointer<ffi.Pointer<realm_list_t>>)>>(
      'realm_list_resolve_in');
  late final _realm_list_resolve_in = _realm_list_resolve_inPtr.asFunction<
      bool Function(ffi.Pointer<realm_list_t>, ffi.Pointer<realm_t>,
          ffi.Pointer<ffi.Pointer<realm_list_t>>)>();

  /// Set the value at @a index.
  ///
  /// @param value The value to set.
  /// @return True if no exception occurred.
  bool realm_list_set(
    ffi.Pointer<realm_list_t> arg0,
    int index,
    realm_value_t value,
  ) {
    return _realm_list_set(
      arg0,
      index,
      value,
    );
  }

  late final _realm_list_setPtr = _lookup<
      ffi.NativeFunction<
          ffi.Bool Function(ffi.Pointer<realm_list_t>, ffi.Size,
              realm_value_t)>>('realm_list_set');
  late final _realm_list_set = _realm_list_setPtr.asFunction<
      bool Function(ffi.Pointer<realm_list_t>, int, realm_value_t)>();

  ffi.Pointer<realm_dictionary_t> realm_list_set_dictionary(
    ffi.Pointer<realm_list_t> list,
    int index,
  ) {
    return _realm_list_set_dictionary(
      list,
      index,
    );
  }

  late final _realm_list_set_dictionaryPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<realm_dictionary_t> Function(ffi.Pointer<realm_list_t>,
              ffi.Size)>>('realm_list_set_dictionary');
  late final _realm_list_set_dictionary =
      _realm_list_set_dictionaryPtr.asFunction<
          ffi.Pointer<realm_dictionary_t> Function(
              ffi.Pointer<realm_list_t>, int)>();

  /// Create an embedded object at a given position.
  ///
  /// @return A non-NULL pointer if the object was created successfully.
  ffi.Pointer<realm_object_t> realm_list_set_embedded(
    ffi.Pointer<realm_list_t> arg0,
    int index,
  ) {
    return _realm_list_set_embedded(
      arg0,
      index,
    );
  }

  late final _realm_list_set_embeddedPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<realm_object_t> Function(
              ffi.Pointer<realm_list_t>, ffi.Size)>>('realm_list_set_embedded');
  late final _realm_list_set_embedded = _realm_list_set_embeddedPtr.asFunction<
      ffi.Pointer<realm_object_t> Function(ffi.Pointer<realm_list_t>, int)>();

  /// Set a collection inside a list (only available for mixed types).
  /// If the list already contains a collection of the requested type, the
  /// operation is idempotent.
  ///
  /// @param list valid ptr to a list where a nested collection needs to be set
  /// @param index position in the list where to set the collection
  /// @return a valid ptr representing the collection just set
  ffi.Pointer<realm_list_t> realm_list_set_list(
    ffi.Pointer<realm_list_t> list,
    int index,
  ) {
    return _realm_list_set_list(
      list,
      index,
    );
  }

  late final _realm_list_set_listPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<realm_list_t> Function(
              ffi.Pointer<realm_list_t>, ffi.Size)>>('realm_list_set_list');
  late final _realm_list_set_list = _realm_list_set_listPtr.asFunction<
      ffi.Pointer<realm_list_t> Function(ffi.Pointer<realm_list_t>, int)>();

  /// Get the size of a list, in number of elements.
  ///
  /// This function may fail if the object owning the list has been deleted.
  ///
  /// @param out_size Where to put the list size. May be NULL.
  /// @return True if no exception occurred.
  bool realm_list_size(
    ffi.Pointer<realm_list_t> arg0,
    ffi.Pointer<ffi.Size> out_size,
  ) {
    return _realm_list_size(
      arg0,
      out_size,
    );
  }

  late final _realm_list_sizePtr = _lookup<
      ffi.NativeFunction<
          ffi.Bool Function(ffi.Pointer<realm_list_t>,
              ffi.Pointer<ffi.Size>)>>('realm_list_size');
  late final _realm_list_size = _realm_list_sizePtr.asFunction<
      bool Function(ffi.Pointer<realm_list_t>, ffi.Pointer<ffi.Size>)>();

  /// Convert a list to results.
  ///
  /// @return A non-null pointer if no exception occurred.
  ffi.Pointer<realm_results_t> realm_list_to_results(
    ffi.Pointer<realm_list_t> arg0,
  ) {
    return _realm_list_to_results(
      arg0,
    );
  }

  late final _realm_list_to_resultsPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<realm_results_t> Function(
              ffi.Pointer<realm_list_t>)>>('realm_list_to_results');
  late final _realm_list_to_results = _realm_list_to_resultsPtr.asFunction<
      ffi.Pointer<realm_results_t> Function(ffi.Pointer<realm_list_t>)>();

  /// Increment atomically property specified as parameter by value, for the object passed as argument.
  /// @param object valid ptr to an object store in the database
  /// @param property_key id of the property to change
  /// @param value increment for the property passed as argument
  /// @return True if not exception occurred.
  bool realm_object_add_int(
    ffi.Pointer<realm_object_t> object,
    int property_key,
    int value,
  ) {
    return _realm_object_add_int(
      object,
      property_key,
      value,
    );
  }

  late final _realm_object_add_intPtr = _lookup<
      ffi.NativeFunction<
          ffi.Bool Function(ffi.Pointer<realm_object_t>, realm_property_key_t,
              ffi.Int64)>>('realm_object_add_int');
  late final _realm_object_add_int = _realm_object_add_intPtr
      .asFunction<bool Function(ffi.Pointer<realm_object_t>, int, int)>();

  /// Subscribe to notifications for this object.
  ///
  /// @return A non-null pointer if no exception occurred.
  ffi.Pointer<realm_notification_token_t>
      realm_object_add_notification_callback(
    ffi.Pointer<realm_object_t> arg0,
    ffi.Pointer<ffi.Void> userdata,
    realm_free_userdata_func_t userdata_free,
    ffi.Pointer<realm_key_path_array_t> key_path_array,
    realm_on_object_change_func_t on_change,
  ) {
    return _realm_object_add_notification_callback(
      arg0,
      userdata,
      userdata_free,
      key_path_array,
      on_change,
    );
  }

  late final _realm_object_add_notification_callbackPtr = _lookup<
          ffi.NativeFunction<
              ffi.Pointer<realm_notification_token_t> Function(
                  ffi.Pointer<realm_object_t>,
                  ffi.Pointer<ffi.Void>,
                  realm_free_userdata_func_t,
                  ffi.Pointer<realm_key_path_array_t>,
                  realm_on_object_change_func_t)>>(
      'realm_object_add_notification_callback');
  late final _realm_object_add_notification_callback =
      _realm_object_add_notification_callbackPtr.asFunction<
          ffi.Pointer<realm_notification_token_t> Function(
              ffi.Pointer<realm_object_t>,
              ffi.Pointer<ffi.Void>,
              realm_free_userdata_func_t,
              ffi.Pointer<realm_key_path_array_t>,
              realm_on_object_change_func_t)>();

  /// Get a `realm_link_t` representing a link to @a object.
  ///
  /// This function cannot fail.
  realm_link_t realm_object_as_link(
    ffi.Pointer<realm_object_t> object,
  ) {
    return _realm_object_as_link(
      object,
    );
  }

  late final _realm_object_as_linkPtr = _lookup<
          ffi
          .NativeFunction<realm_link_t Function(ffi.Pointer<realm_object_t>)>>(
      'realm_object_as_link');
  late final _realm_object_as_link = _realm_object_as_linkPtr
      .asFunction<realm_link_t Function(ffi.Pointer<realm_object_t>)>();

  /// Get the column keys for the properties that were modified in an object
  /// notification.
  ///
  /// This function cannot fail.
  ///
  /// @param out_modified Where the column keys should be written. May be NULL.
  /// @param max The maximum number of column keys to write.
  /// @return The number of column keys written to @a out_modified, or the number
  /// of modified properties if @a out_modified is NULL.
  int realm_object_changes_get_modified_properties(
    ffi.Pointer<realm_object_changes_t> arg0,
    ffi.Pointer<realm_property_key_t> out_modified,
    int max,
  ) {
    return _realm_object_changes_get_modified_properties(
      arg0,
      out_modified,
      max,
    );
  }

  late final _realm_object_changes_get_modified_propertiesPtr = _lookup<
      ffi.NativeFunction<
          ffi.Size Function(
              ffi.Pointer<realm_object_changes_t>,
              ffi.Pointer<realm_property_key_t>,
              ffi.Size)>>('realm_object_changes_get_modified_properties');
  late final _realm_object_changes_get_modified_properties =
      _realm_object_changes_get_modified_propertiesPtr.asFunction<
          int Function(ffi.Pointer<realm_object_changes_t>,
              ffi.Pointer<realm_property_key_t>, int)>();

  /// Get the number of properties that were modified in an object notification.
  ///
  /// This function cannot fail.
  int realm_object_changes_get_num_modified_properties(
    ffi.Pointer<realm_object_changes_t> arg0,
  ) {
    return _realm_object_changes_get_num_modified_properties(
      arg0,
    );
  }

  late final _realm_object_changes_get_num_modified_propertiesPtr = _lookup<
          ffi.NativeFunction<
              ffi.Size Function(ffi.Pointer<realm_object_changes_t>)>>(
      'realm_object_changes_get_num_modified_properties');
  late final _realm_object_changes_get_num_modified_properties =
      _realm_object_changes_get_num_modified_propertiesPtr
          .asFunction<int Function(ffi.Pointer<realm_object_changes_t>)>();

  /// True if an object notification indicates that the object was deleted.
  ///
  /// This function cannot fail.
  bool realm_object_changes_is_deleted(
    ffi.Pointer<realm_object_changes_t> arg0,
  ) {
    return _realm_object_changes_is_deleted(
      arg0,
    );
  }

  late final _realm_object_changes_is_deletedPtr = _lookup<
          ffi.NativeFunction<
              ffi.Bool Function(ffi.Pointer<realm_object_changes_t>)>>(
      'realm_object_changes_is_deleted');
  late final _realm_object_changes_is_deleted =
      _realm_object_changes_is_deletedPtr
          .asFunction<bool Function(ffi.Pointer<realm_object_changes_t>)>();

  /// Create an object in a class without a primary key.
  ///
  /// @return A non-NULL pointer if the object was created successfully.
  ffi.Pointer<realm_object_t> realm_object_create(
    ffi.Pointer<realm_t> arg0,
    int arg1,
  ) {
    return _realm_object_create(
      arg0,
      arg1,
    );
  }

  late final _realm_object_createPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<realm_object_t> Function(
              ffi.Pointer<realm_t>, realm_class_key_t)>>('realm_object_create');
  late final _realm_object_create = _realm_object_createPtr.asFunction<
      ffi.Pointer<realm_object_t> Function(ffi.Pointer<realm_t>, int)>();

  /// Create an object in a class with a primary key. Will not succeed if an
  /// object with the given primary key value already exists.
  ///
  /// @return A non-NULL pointer if the object was created successfully.
  ffi.Pointer<realm_object_t> realm_object_create_with_primary_key(
    ffi.Pointer<realm_t> arg0,
    int arg1,
    realm_value_t pk,
  ) {
    return _realm_object_create_with_primary_key(
      arg0,
      arg1,
      pk,
    );
  }

  late final _realm_object_create_with_primary_keyPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<realm_object_t> Function(
              ffi.Pointer<realm_t>,
              realm_class_key_t,
              realm_value_t)>>('realm_object_create_with_primary_key');
  late final _realm_object_create_with_primary_key =
      _realm_object_create_with_primary_keyPtr.asFunction<
          ffi.Pointer<realm_object_t> Function(
              ffi.Pointer<realm_t>, int, realm_value_t)>();

  /// Delete a realm object.
  ///
  /// Note: This does not call `realm_release()` on the `realm_object_t` instance.
  ///
  /// @return True if no exception occurred.
  bool realm_object_delete(
    ffi.Pointer<realm_object_t> arg0,
  ) {
    return _realm_object_delete(
      arg0,
    );
  }

  late final _realm_object_deletePtr = _lookup<
          ffi.NativeFunction<ffi.Bool Function(ffi.Pointer<realm_object_t>)>>(
      'realm_object_delete');
  late final _realm_object_delete = _realm_object_deletePtr
      .asFunction<bool Function(ffi.Pointer<realm_object_t>)>();

  /// Find all objects in class.
  ///
  /// Note: This is faster than running a query matching all objects (such as
  /// "TRUEPREDICATE").
  ///
  /// @return A non-NULL pointer if no exception was thrown.
  ffi.Pointer<realm_results_t> realm_object_find_all(
    ffi.Pointer<realm_t> arg0,
    int arg1,
  ) {
    return _realm_object_find_all(
      arg0,
      arg1,
    );
  }

  late final _realm_object_find_allPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<realm_results_t> Function(ffi.Pointer<realm_t>,
              realm_class_key_t)>>('realm_object_find_all');
  late final _realm_object_find_all = _realm_object_find_allPtr.asFunction<
      ffi.Pointer<realm_results_t> Function(ffi.Pointer<realm_t>, int)>();

  /// Find an object with a particular primary key value.
  ///
  /// @param out_found A pointer to a boolean that will be set to true or false if
  /// no error occurred.
  /// @return A non-NULL pointer if the object was found and no exception occurred.
  ffi.Pointer<realm_object_t> realm_object_find_with_primary_key(
    ffi.Pointer<realm_t> arg0,
    int arg1,
    realm_value_t pk,
    ffi.Pointer<ffi.Bool> out_found,
  ) {
    return _realm_object_find_with_primary_key(
      arg0,
      arg1,
      pk,
      out_found,
    );
  }

  late final _realm_object_find_with_primary_keyPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<realm_object_t> Function(
              ffi.Pointer<realm_t>,
              realm_class_key_t,
              realm_value_t,
              ffi.Pointer<ffi.Bool>)>>('realm_object_find_with_primary_key');
  late final _realm_object_find_with_primary_key =
      _realm_object_find_with_primary_keyPtr.asFunction<
          ffi.Pointer<realm_object_t> Function(ffi.Pointer<realm_t>, int,
              realm_value_t, ffi.Pointer<ffi.Bool>)>();

  /// Get an object from a thread-safe reference, potentially originating in a
  /// different `realm_t` instance
  ffi.Pointer<realm_object_t> realm_object_from_thread_safe_reference(
    ffi.Pointer<realm_t> arg0,
    ffi.Pointer<realm_thread_safe_reference_t> arg1,
  ) {
    return _realm_object_from_thread_safe_reference(
      arg0,
      arg1,
    );
  }

  late final _realm_object_from_thread_safe_referencePtr = _lookup<
          ffi.NativeFunction<
              ffi.Pointer<realm_object_t> Function(ffi.Pointer<realm_t>,
                  ffi.Pointer<realm_thread_safe_reference_t>)>>(
      'realm_object_from_thread_safe_reference');
  late final _realm_object_from_thread_safe_reference =
      _realm_object_from_thread_safe_referencePtr.asFunction<
          ffi.Pointer<realm_object_t> Function(ffi.Pointer<realm_t>,
              ffi.Pointer<realm_thread_safe_reference_t>)>();

  /// Get the key for this object.
  ///
  /// This function cannot fail.
  int realm_object_get_key(
    ffi.Pointer<realm_object_t> object,
  ) {
    return _realm_object_get_key(
      object,
    );
  }

  late final _realm_object_get_keyPtr = _lookup<
      ffi.NativeFunction<
          realm_object_key_t Function(
              ffi.Pointer<realm_object_t>)>>('realm_object_get_key');
  late final _realm_object_get_key = _realm_object_get_keyPtr
      .asFunction<int Function(ffi.Pointer<realm_object_t>)>();

  /// Create an object in a class with a primary key. If an object with the given
  /// primary key value already exists, that object will be returned.
  ///
  /// @return A non-NULL pointer if the object was found/created successfully.
  ffi.Pointer<realm_object_t> realm_object_get_or_create_with_primary_key(
    ffi.Pointer<realm_t> arg0,
    int arg1,
    realm_value_t pk,
    ffi.Pointer<ffi.Bool> did_create,
  ) {
    return _realm_object_get_or_create_with_primary_key(
      arg0,
      arg1,
      pk,
      did_create,
    );
  }

  late final _realm_object_get_or_create_with_primary_keyPtr = _lookup<
          ffi.NativeFunction<
              ffi.Pointer<realm_object_t> Function(ffi.Pointer<realm_t>,
                  realm_class_key_t, realm_value_t, ffi.Pointer<ffi.Bool>)>>(
      'realm_object_get_or_create_with_primary_key');
  late final _realm_object_get_or_create_with_primary_key =
      _realm_object_get_or_create_with_primary_keyPtr.asFunction<
          ffi.Pointer<realm_object_t> Function(ffi.Pointer<realm_t>, int,
              realm_value_t, ffi.Pointer<ffi.Bool>)>();

  /// Get the parent object for the object passed as argument. Only works for embedded objects.
  /// @return true, if no errors occurred.
  bool realm_object_get_parent(
    ffi.Pointer<realm_object_t> object,
    ffi.Pointer<ffi.Pointer<realm_object_t>> parent,
    ffi.Pointer<realm_class_key_t> class_key,
  ) {
    return _realm_object_get_parent(
      object,
      parent,
      class_key,
    );
  }

  late final _realm_object_get_parentPtr = _lookup<
      ffi.NativeFunction<
          ffi.Bool Function(
              ffi.Pointer<realm_object_t>,
              ffi.Pointer<ffi.Pointer<realm_object_t>>,
              ffi.Pointer<realm_class_key_t>)>>('realm_object_get_parent');
  late final _realm_object_get_parent = _realm_object_get_parentPtr.asFunction<
      bool Function(
          ffi.Pointer<realm_object_t>,
          ffi.Pointer<ffi.Pointer<realm_object_t>>,
          ffi.Pointer<realm_class_key_t>)>();

  /// Get the table for this object.
  ///
  /// This function cannot fail.
  int realm_object_get_table(
    ffi.Pointer<realm_object_t> object,
  ) {
    return _realm_object_get_table(
      object,
    );
  }

  late final _realm_object_get_tablePtr = _lookup<
      ffi.NativeFunction<
          realm_class_key_t Function(
              ffi.Pointer<realm_object_t>)>>('realm_object_get_table');
  late final _realm_object_get_table = _realm_object_get_tablePtr
      .asFunction<int Function(ffi.Pointer<realm_object_t>)>();

  /// True if this object still exists in the realm.
  ///
  /// This function cannot fail.
  bool realm_object_is_valid(
    ffi.Pointer<realm_object_t> arg0,
  ) {
    return _realm_object_is_valid(
      arg0,
    );
  }

  late final _realm_object_is_validPtr = _lookup<
          ffi.NativeFunction<ffi.Bool Function(ffi.Pointer<realm_object_t>)>>(
      'realm_object_is_valid');
  late final _realm_object_is_valid = _realm_object_is_validPtr
      .asFunction<bool Function(ffi.Pointer<realm_object_t>)>();

  /// Resolve the Realm object in the provided Realm.
  ///
  /// This is equivalent to producing a thread-safe reference and resolving it in the target realm.
  ///
  /// If the object can be resolved in the target realm, '*resolved' points to the new object
  /// If the object cannot be resolved in the target realm, '*resolved' will be null.
  /// @return True if no exception occurred (except exceptions that may normally occur if resolution fails)
  bool realm_object_resolve_in(
    ffi.Pointer<realm_object_t> live_object,
    ffi.Pointer<realm_t> target_realm,
    ffi.Pointer<ffi.Pointer<realm_object_t>> resolved,
  ) {
    return _realm_object_resolve_in(
      live_object,
      target_realm,
      resolved,
    );
  }

  late final _realm_object_resolve_inPtr = _lookup<
          ffi.NativeFunction<
              ffi.Bool Function(
                  ffi.Pointer<realm_object_t>,
                  ffi.Pointer<realm_t>,
                  ffi.Pointer<ffi.Pointer<realm_object_t>>)>>(
      'realm_object_resolve_in');
  late final _realm_object_resolve_in = _realm_object_resolve_inPtr.asFunction<
      bool Function(ffi.Pointer<realm_object_t>, ffi.Pointer<realm_t>,
          ffi.Pointer<ffi.Pointer<realm_object_t>>)>();

  /// Serializes an object to json and returns it as string. Serializes a single level of properties only.
  ///
  /// @return a json-serialized representation of the object.
  ffi.Pointer<ffi.Char> realm_object_to_string(
    ffi.Pointer<realm_object_t> arg0,
  ) {
    return _realm_object_to_string(
      arg0,
    );
  }

  late final _realm_object_to_stringPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<realm_object_t>)>>('realm_object_to_string');
  late final _realm_object_to_string = _realm_object_to_stringPtr.asFunction<
      ffi.Pointer<ffi.Char> Function(ffi.Pointer<realm_object_t>)>();

  /// Open a Realm file.
  ///
  /// @param config Realm configuration. If the Realm is already opened on another
  /// thread, validate that the given configuration is compatible
  /// with the existing one.
  /// @return If successful, the Realm object. Otherwise, NULL.
  ffi.Pointer<realm_t> realm_open(
    ffi.Pointer<realm_config_t> config,
  ) {
    return _realm_open(
      config,
    );
  }

  late final _realm_openPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<realm_t> Function(
              ffi.Pointer<realm_config_t>)>>('realm_open');
  late final _realm_open = _realm_openPtr
      .asFunction<ffi.Pointer<realm_t> Function(ffi.Pointer<realm_config_t>)>();

  /// Parse a query string and append it to an existing query via logical &&.
  /// The query string applies to the same table and Realm as the existing query.
  ///
  /// If the query failed to parse, the parser error is available from
  /// `realm_get_last_error()`.
  ///
  /// @param query_string A zero-terminated string in the Realm Query Language,
  /// optionally containing argument placeholders (`$0`, `$1`,
  /// etc.).
  /// @param num_args The number of arguments for this query.
  /// @param args A pointer to a list of argument values.
  /// @return A non-null pointer if the query was successfully parsed and no
  /// exception occurred.
  ffi.Pointer<realm_query_t> realm_query_append_query(
    ffi.Pointer<realm_query_t> arg0,
    ffi.Pointer<ffi.Char> query_string,
    int num_args,
    ffi.Pointer<realm_query_arg_t> args,
  ) {
    return _realm_query_append_query(
      arg0,
      query_string,
      num_args,
      args,
    );
  }

  late final _realm_query_append_queryPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<realm_query_t> Function(
              ffi.Pointer<realm_query_t>,
              ffi.Pointer<ffi.Char>,
              ffi.Size,
              ffi.Pointer<realm_query_arg_t>)>>('realm_query_append_query');
  late final _realm_query_append_query =
      _realm_query_append_queryPtr.asFunction<
          ffi.Pointer<realm_query_t> Function(ffi.Pointer<realm_query_t>,
              ffi.Pointer<ffi.Char>, int, ffi.Pointer<realm_query_arg_t>)>();

  /// Count the number of objects found by this query.
  bool realm_query_count(
    ffi.Pointer<realm_query_t> arg0,
    ffi.Pointer<ffi.Size> out_count,
  ) {
    return _realm_query_count(
      arg0,
      out_count,
    );
  }

  late final _realm_query_countPtr = _lookup<
      ffi.NativeFunction<
          ffi.Bool Function(ffi.Pointer<realm_query_t>,
              ffi.Pointer<ffi.Size>)>>('realm_query_count');
  late final _realm_query_count = _realm_query_countPtr.asFunction<
      bool Function(ffi.Pointer<realm_query_t>, ffi.Pointer<ffi.Size>)>();

  /// Delete all objects matched by a query.
  bool realm_query_delete_all(
    ffi.Pointer<realm_query_t> arg0,
  ) {
    return _realm_query_delete_all(
      arg0,
    );
  }

  late final _realm_query_delete_allPtr = _lookup<
          ffi.NativeFunction<ffi.Bool Function(ffi.Pointer<realm_query_t>)>>(
      'realm_query_delete_all');
  late final _realm_query_delete_all = _realm_query_delete_allPtr
      .asFunction<bool Function(ffi.Pointer<realm_query_t>)>();

  /// Produce a results object for this query.
  ///
  /// Note: This does not actually run the query until the results are accessed in
  /// some way.
  ///
  /// @return A non-null pointer if no exception occurred.
  ffi.Pointer<realm_results_t> realm_query_find_all(
    ffi.Pointer<realm_query_t> arg0,
  ) {
    return _realm_query_find_all(
      arg0,
    );
  }

  late final _realm_query_find_allPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<realm_results_t> Function(
              ffi.Pointer<realm_query_t>)>>('realm_query_find_all');
  late final _realm_query_find_all = _realm_query_find_allPtr.asFunction<
      ffi.Pointer<realm_results_t> Function(ffi.Pointer<realm_query_t>)>();

  /// Return the first object matched by this query.
  ///
  /// Note: This function can only produce objects, not values. Use the
  /// `realm_results_t` returned by `realm_query_find_all()` to retrieve
  /// values from a list of primitive values.
  ///
  /// @param out_value Where to write the result, if any object matched the query.
  /// May be NULL.
  /// @param out_found Where to write whether the object was found. May be NULL.
  /// @return True if no exception occurred.
  bool realm_query_find_first(
    ffi.Pointer<realm_query_t> arg0,
    ffi.Pointer<realm_value_t> out_value,
    ffi.Pointer<ffi.Bool> out_found,
  ) {
    return _realm_query_find_first(
      arg0,
      out_value,
      out_found,
    );
  }

  late final _realm_query_find_firstPtr = _lookup<
      ffi.NativeFunction<
          ffi.Bool Function(
              ffi.Pointer<realm_query_t>,
              ffi.Pointer<realm_value_t>,
              ffi.Pointer<ffi.Bool>)>>('realm_query_find_first');
  late final _realm_query_find_first = _realm_query_find_firstPtr.asFunction<
      bool Function(ffi.Pointer<realm_query_t>, ffi.Pointer<realm_value_t>,
          ffi.Pointer<ffi.Bool>)>();

  /// Get textual representation of query
  ///
  /// @return a string containing the description. The string memory is managed by the query object.
  ffi.Pointer<ffi.Char> realm_query_get_description(
    ffi.Pointer<realm_query_t> arg0,
  ) {
    return _realm_query_get_description(
      arg0,
    );
  }

  late final _realm_query_get_descriptionPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<realm_query_t>)>>('realm_query_get_description');
  late final _realm_query_get_description = _realm_query_get_descriptionPtr
      .asFunction<ffi.Pointer<ffi.Char> Function(ffi.Pointer<realm_query_t>)>();

  /// Parse a query string and bind it to a table.
  ///
  /// If the query failed to parse, the parser error is available from
  /// `realm_get_last_error()`.
  ///
  /// @param target_table The table on which to run this query.
  /// @param query_string A zero-terminated string in the Realm Query Language,
  /// optionally containing argument placeholders (`$0`, `$1`,
  /// etc.).
  /// @param num_args The number of arguments for this query.
  /// @param args A pointer to a list of argument values.
  /// @return A non-null pointer if the query was successfully parsed and no
  /// exception occurred.
  ffi.Pointer<realm_query_t> realm_query_parse(
    ffi.Pointer<realm_t> arg0,
    int target_table,
    ffi.Pointer<ffi.Char> query_string,
    int num_args,
    ffi.Pointer<realm_query_arg_t> args,
  ) {
    return _realm_query_parse(
      arg0,
      target_table,
      query_string,
      num_args,
      args,
    );
  }

  late final _realm_query_parsePtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<realm_query_t> Function(
              ffi.Pointer<realm_t>,
              realm_class_key_t,
              ffi.Pointer<ffi.Char>,
              ffi.Size,
              ffi.Pointer<realm_query_arg_t>)>>('realm_query_parse');
  late final _realm_query_parse = _realm_query_parsePtr.asFunction<
      ffi.Pointer<realm_query_t> Function(ffi.Pointer<realm_t>, int,
          ffi.Pointer<ffi.Char>, int, ffi.Pointer<realm_query_arg_t>)>();

  /// Parse a query string and bind it to a list.
  ///
  /// If the query failed to parse, the parser error is available from
  /// `realm_get_last_error()`.
  ///
  /// @param target_list The list on which to run this query.
  /// @param query_string A string in the Realm Query Language, optionally
  /// containing argument placeholders (`$0`, `$1`, etc.).
  /// @param num_args The number of arguments for this query.
  /// @param args A pointer to a list of argument values.
  /// @return A non-null pointer if the query was successfully parsed and no
  /// exception occurred.
  ffi.Pointer<realm_query_t> realm_query_parse_for_list(
    ffi.Pointer<realm_list_t> target_list,
    ffi.Pointer<ffi.Char> query_string,
    int num_args,
    ffi.Pointer<realm_query_arg_t> args,
  ) {
    return _realm_query_parse_for_list(
      target_list,
      query_string,
      num_args,
      args,
    );
  }

  late final _realm_query_parse_for_listPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<realm_query_t> Function(
              ffi.Pointer<realm_list_t>,
              ffi.Pointer<ffi.Char>,
              ffi.Size,
              ffi.Pointer<realm_query_arg_t>)>>('realm_query_parse_for_list');
  late final _realm_query_parse_for_list =
      _realm_query_parse_for_listPtr.asFunction<
          ffi.Pointer<realm_query_t> Function(ffi.Pointer<realm_list_t>,
              ffi.Pointer<ffi.Char>, int, ffi.Pointer<realm_query_arg_t>)>();

  /// Parse a query string and bind it to another query result.
  ///
  /// If the query failed to parse, the parser error is available from
  /// `realm_get_last_error()`.
  ///
  /// @param target_results The results on which to run this query.
  /// @param query_string A zero-terminated string in the Realm Query Language,
  /// optionally containing argument placeholders (`$0`, `$1`,
  /// etc.).
  /// @param num_args The number of arguments for this query.
  /// @param args A pointer to a list of argument values.
  /// @return A non-null pointer if the query was successfully parsed and no
  /// exception occurred.
  ffi.Pointer<realm_query_t> realm_query_parse_for_results(
    ffi.Pointer<realm_results_t> target_results,
    ffi.Pointer<ffi.Char> query_string,
    int num_args,
    ffi.Pointer<realm_query_arg_t> args,
  ) {
    return _realm_query_parse_for_results(
      target_results,
      query_string,
      num_args,
      args,
    );
  }

  late final _realm_query_parse_for_resultsPtr = _lookup<
          ffi.NativeFunction<
              ffi.Pointer<realm_query_t> Function(
                  ffi.Pointer<realm_results_t>,
                  ffi.Pointer<ffi.Char>,
                  ffi.Size,
                  ffi.Pointer<realm_query_arg_t>)>>(
      'realm_query_parse_for_results');
  late final _realm_query_parse_for_results =
      _realm_query_parse_for_resultsPtr.asFunction<
          ffi.Pointer<realm_query_t> Function(ffi.Pointer<realm_results_t>,
              ffi.Pointer<ffi.Char>, int, ffi.Pointer<realm_query_arg_t>)>();

  /// Parse a query string and bind it to a set.
  ///
  /// If the query failed to parse, the parser error is available from
  /// `realm_get_last_error()`.
  ///
  /// @param target_set The set on which to run this query.
  /// @param query_string A string in the Realm Query Language, optionally
  /// containing argument placeholders (`$0`, `$1`, etc.).
  /// @param num_args The number of arguments for this query.
  /// @param args A pointer to a list of argument values.
  /// @return A non-null pointer if the query was successfully parsed and no
  /// exception occurred.
  ffi.Pointer<realm_query_t> realm_query_parse_for_set(
    ffi.Pointer<realm_set_t> target_set,
    ffi.Pointer<ffi.Char> query_string,
    int num_args,
    ffi.Pointer<realm_query_arg_t> args,
  ) {
    return _realm_query_parse_for_set(
      target_set,
      query_string,
      num_args,
      args,
    );
  }

  late final _realm_query_parse_for_setPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<realm_query_t> Function(
              ffi.Pointer<realm_set_t>,
              ffi.Pointer<ffi.Char>,
              ffi.Size,
              ffi.Pointer<realm_query_arg_t>)>>('realm_query_parse_for_set');
  late final _realm_query_parse_for_set =
      _realm_query_parse_for_setPtr.asFunction<
          ffi.Pointer<realm_query_t> Function(ffi.Pointer<realm_set_t>,
              ffi.Pointer<ffi.Char>, int, ffi.Pointer<realm_query_arg_t>)>();

  /// Refresh the view of the realm file.
  ///
  /// If another process or thread has made changes to the realm file, this causes
  /// those changes to become visible in this realm instance.
  ///
  /// This calls `advance_read()` at the Core layer.
  ///
  /// @return True if no exceptions are thrown, false otherwise.
  bool realm_refresh(
    ffi.Pointer<realm_t> arg0,
    ffi.Pointer<ffi.Bool> did_refresh,
  ) {
    return _realm_refresh(
      arg0,
      did_refresh,
    );
  }

  late final _realm_refreshPtr = _lookup<
      ffi.NativeFunction<
          ffi.Bool Function(
              ffi.Pointer<realm_t>, ffi.Pointer<ffi.Bool>)>>('realm_refresh');
  late final _realm_refresh = _realm_refreshPtr
      .asFunction<bool Function(ffi.Pointer<realm_t>, ffi.Pointer<ffi.Bool>)>();

  /// In case of exception thrown in user code callbacks, this api will allow the sdk to store the user code exception
  /// and retrieve a it later via realm_get_last_error.
  /// Most importantly the SDK is responsible to handle the memory pointed by user_code_error.
  /// @param usercode_error pointer representing whatever object the SDK treats as exception/error.
  void realm_register_user_code_callback_error(
    ffi.Pointer<ffi.Void> usercode_error,
  ) {
    return _realm_register_user_code_callback_error(
      usercode_error,
    );
  }

  late final _realm_register_user_code_callback_errorPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>(
          'realm_register_user_code_callback_error');
  late final _realm_register_user_code_callback_error =
      _realm_register_user_code_callback_errorPtr
          .asFunction<void Function(ffi.Pointer<ffi.Void>)>();

  /// Free any Realm C Wrapper object.
  ///
  /// Note: Any pointer returned from a library function is owned by the caller.
  /// The caller is responsible for calling `realm_release()`. The only
  /// exception from this is C++ bridge functions that return `void*`, with
  /// the prefix `_realm`.
  ///
  /// Note: C++ destructors are typically `noexcept`, so it is likely that an
  /// exception will crash the process.
  ///
  /// @param ptr A pointer to a Realm C Wrapper object. May be NULL.
  void realm_release(
    ffi.Pointer<ffi.Void> ptr,
  ) {
    return _realm_release(
      ptr,
    );
  }

  late final _realm_releasePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>(
          'realm_release');
  late final _realm_release =
      _realm_releasePtr.asFunction<void Function(ffi.Pointer<ffi.Void>)>();

  /// Find and delete the table passed as parementer for the realm instance passed to this function.
  /// @param table_name for the table the user wants to delete
  /// @param table_deleted in order to indicate if the table was actually deleted from realm
  /// @return true if no error has occurred, false otherwise
  bool realm_remove_table(
    ffi.Pointer<realm_t> arg0,
    ffi.Pointer<ffi.Char> table_name,
    ffi.Pointer<ffi.Bool> table_deleted,
  ) {
    return _realm_remove_table(
      arg0,
      table_name,
      table_deleted,
    );
  }

  late final _realm_remove_tablePtr = _lookup<
      ffi.NativeFunction<
          ffi.Bool Function(ffi.Pointer<realm_t>, ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Bool>)>>('realm_remove_table');
  late final _realm_remove_table = _realm_remove_tablePtr.asFunction<
      bool Function(ffi.Pointer<realm_t>, ffi.Pointer<ffi.Char>,
          ffi.Pointer<ffi.Bool>)>();

  ffi.Pointer<realm_notification_token_t>
      realm_results_add_notification_callback(
    ffi.Pointer<realm_results_t> arg0,
    ffi.Pointer<ffi.Void> userdata,
    realm_free_userdata_func_t userdata_free,
    ffi.Pointer<realm_key_path_array_t> key_path_array,
    realm_on_collection_change_func_t arg4,
  ) {
    return _realm_results_add_notification_callback(
      arg0,
      userdata,
      userdata_free,
      key_path_array,
      arg4,
    );
  }

  late final _realm_results_add_notification_callbackPtr = _lookup<
          ffi.NativeFunction<
              ffi.Pointer<realm_notification_token_t> Function(
                  ffi.Pointer<realm_results_t>,
                  ffi.Pointer<ffi.Void>,
                  realm_free_userdata_func_t,
                  ffi.Pointer<realm_key_path_array_t>,
                  realm_on_collection_change_func_t)>>(
      'realm_results_add_notification_callback');
  late final _realm_results_add_notification_callback =
      _realm_results_add_notification_callbackPtr.asFunction<
          ffi.Pointer<realm_notification_token_t> Function(
              ffi.Pointer<realm_results_t>,
              ffi.Pointer<ffi.Void>,
              realm_free_userdata_func_t,
              ffi.Pointer<realm_key_path_array_t>,
              realm_on_collection_change_func_t)>();

  /// Compute the average value of a property in the results.
  ///
  /// Note: For numeric columns, the average is always converted to double.
  ///
  /// @param out_average Where to write the result.
  /// @param out_found Set to true if there are matching rows.
  /// @return True if no exception occurred.
  bool realm_results_average(
    ffi.Pointer<realm_results_t> arg0,
    int arg1,
    ffi.Pointer<realm_value_t> out_average,
    ffi.Pointer<ffi.Bool> out_found,
  ) {
    return _realm_results_average(
      arg0,
      arg1,
      out_average,
      out_found,
    );
  }

  late final _realm_results_averagePtr = _lookup<
      ffi.NativeFunction<
          ffi.Bool Function(
              ffi.Pointer<realm_results_t>,
              realm_property_key_t,
              ffi.Pointer<realm_value_t>,
              ffi.Pointer<ffi.Bool>)>>('realm_results_average');
  late final _realm_results_average = _realm_results_averagePtr.asFunction<
      bool Function(ffi.Pointer<realm_results_t>, int,
          ffi.Pointer<realm_value_t>, ffi.Pointer<ffi.Bool>)>();

  /// Count the number of results.
  ///
  /// If the result is "live" (not a snapshot), this may rerun the query if things
  /// have changed.
  ///
  /// @return True if no exception occurred.
  bool realm_results_count(
    ffi.Pointer<realm_results_t> arg0,
    ffi.Pointer<ffi.Size> out_count,
  ) {
    return _realm_results_count(
      arg0,
      out_count,
    );
  }

  late final _realm_results_countPtr = _lookup<
      ffi.NativeFunction<
          ffi.Bool Function(ffi.Pointer<realm_results_t>,
              ffi.Pointer<ffi.Size>)>>('realm_results_count');
  late final _realm_results_count = _realm_results_countPtr.asFunction<
      bool Function(ffi.Pointer<realm_results_t>, ffi.Pointer<ffi.Size>)>();

  /// Delete all objects in the result.
  ///
  /// If the result if "live" (not a snapshot), this may rerun the query if things
  /// have changed.
  ///
  /// @return True if no exception occurred.
  bool realm_results_delete_all(
    ffi.Pointer<realm_results_t> arg0,
  ) {
    return _realm_results_delete_all(
      arg0,
    );
  }

  late final _realm_results_delete_allPtr = _lookup<
          ffi.NativeFunction<ffi.Bool Function(ffi.Pointer<realm_results_t>)>>(
      'realm_results_delete_all');
  late final _realm_results_delete_all = _realm_results_delete_allPtr
      .asFunction<bool Function(ffi.Pointer<realm_results_t>)>();

  /// Create a new results object by removing duplicates
  ///
  /// @param distinct_string Specifies a distinct condition. It has the format
  /// <param> ["," <param>]*
  /// <param> ::= <prop> ["." <prop>]*
  /// @return A non-null pointer if no exception occurred.
  ffi.Pointer<realm_results_t> realm_results_distinct(
    ffi.Pointer<realm_results_t> results,
    ffi.Pointer<ffi.Char> distinct_string,
  ) {
    return _realm_results_distinct(
      results,
      distinct_string,
    );
  }

  late final _realm_results_distinctPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<realm_results_t> Function(ffi.Pointer<realm_results_t>,
              ffi.Pointer<ffi.Char>)>>('realm_results_distinct');
  late final _realm_results_distinct = _realm_results_distinctPtr.asFunction<
      ffi.Pointer<realm_results_t> Function(
          ffi.Pointer<realm_results_t>, ffi.Pointer<ffi.Char>)>();

  /// Create a new results object by further filtering existing result.
  ///
  /// @return A non-null pointer if no exception occurred.
  ffi.Pointer<realm_results_t> realm_results_filter(
    ffi.Pointer<realm_results_t> arg0,
    ffi.Pointer<realm_query_t> arg1,
  ) {
    return _realm_results_filter(
      arg0,
      arg1,
    );
  }

  late final _realm_results_filterPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<realm_results_t> Function(ffi.Pointer<realm_results_t>,
              ffi.Pointer<realm_query_t>)>>('realm_results_filter');
  late final _realm_results_filter = _realm_results_filterPtr.asFunction<
      ffi.Pointer<realm_results_t> Function(
          ffi.Pointer<realm_results_t>, ffi.Pointer<realm_query_t>)>();

  /// Find the index for the value passed as parameter inside realm results pointer passed a input parameter.
  /// @param value the value to find inside the realm results
  /// @param out_index the index where the object has been found, or realm::not_found
  /// @param out_found boolean indicating if the value has been found or not
  /// @return true if no error occurred, false otherwise
  bool realm_results_find(
    ffi.Pointer<realm_results_t> arg0,
    ffi.Pointer<realm_value_t> value,
    ffi.Pointer<ffi.Size> out_index,
    ffi.Pointer<ffi.Bool> out_found,
  ) {
    return _realm_results_find(
      arg0,
      value,
      out_index,
      out_found,
    );
  }

  late final _realm_results_findPtr = _lookup<
      ffi.NativeFunction<
          ffi.Bool Function(
              ffi.Pointer<realm_results_t>,
              ffi.Pointer<realm_value_t>,
              ffi.Pointer<ffi.Size>,
              ffi.Pointer<ffi.Bool>)>>('realm_results_find');
  late final _realm_results_find = _realm_results_findPtr.asFunction<
      bool Function(ffi.Pointer<realm_results_t>, ffi.Pointer<realm_value_t>,
          ffi.Pointer<ffi.Size>, ffi.Pointer<ffi.Bool>)>();

  /// Find the index for the realm object passed as parameter inside realm results pointer passed a input parameter.
  /// @param value the value to find inside the realm results
  /// @param out_index the index where the object has been found, or realm::not_found
  /// @param out_found boolean indicating if the value has been found or not
  /// @return true if no error occurred, false otherwise
  bool realm_results_find_object(
    ffi.Pointer<realm_results_t> arg0,
    ffi.Pointer<realm_object_t> value,
    ffi.Pointer<ffi.Size> out_index,
    ffi.Pointer<ffi.Bool> out_found,
  ) {
    return _realm_results_find_object(
      arg0,
      value,
      out_index,
      out_found,
    );
  }

  late final _realm_results_find_objectPtr = _lookup<
      ffi.NativeFunction<
          ffi.Bool Function(
              ffi.Pointer<realm_results_t>,
              ffi.Pointer<realm_object_t>,
              ffi.Pointer<ffi.Size>,
              ffi.Pointer<ffi.Bool>)>>('realm_results_find_object');
  late final _realm_results_find_object =
      _realm_results_find_objectPtr.asFunction<
          bool Function(
              ffi.Pointer<realm_results_t>,
              ffi.Pointer<realm_object_t>,
              ffi.Pointer<ffi.Size>,
              ffi.Pointer<ffi.Bool>)>();

  /// Get an results object from a thread-safe reference, potentially originating
  /// in a different `realm_t` instance
  ffi.Pointer<realm_results_t> realm_results_from_thread_safe_reference(
    ffi.Pointer<realm_t> arg0,
    ffi.Pointer<realm_thread_safe_reference_t> arg1,
  ) {
    return _realm_results_from_thread_safe_reference(
      arg0,
      arg1,
    );
  }

  late final _realm_results_from_thread_safe_referencePtr = _lookup<
          ffi.NativeFunction<
              ffi.Pointer<realm_results_t> Function(ffi.Pointer<realm_t>,
                  ffi.Pointer<realm_thread_safe_reference_t>)>>(
      'realm_results_from_thread_safe_reference');
  late final _realm_results_from_thread_safe_reference =
      _realm_results_from_thread_safe_referencePtr.asFunction<
          ffi.Pointer<realm_results_t> Function(ffi.Pointer<realm_t>,
              ffi.Pointer<realm_thread_safe_reference_t>)>();

  /// Get the matching element at @a index in the results.
  ///
  /// If the result is "live" (not a snapshot), this may rerun the query if things
  /// have changed.
  ///
  /// Note: The bound returned by `realm_results_count()` for a non-snapshot result
  /// is not a reliable way to iterate over elements in the result, because
  /// the result will be live-updated if changes are made in each iteration
  /// that may change the number of query results or even change the
  /// ordering. In other words, this method should probably only be used with
  /// snapshot results.
  ///
  /// @return True if no exception occurred (including out-of-bounds).
  bool realm_results_get(
    ffi.Pointer<realm_results_t> arg0,
    int index,
    ffi.Pointer<realm_value_t> out_value,
  ) {
    return _realm_results_get(
      arg0,
      index,
      out_value,
    );
  }

  late final _realm_results_getPtr = _lookup<
      ffi.NativeFunction<
          ffi.Bool Function(ffi.Pointer<realm_results_t>, ffi.Size,
              ffi.Pointer<realm_value_t>)>>('realm_results_get');
  late final _realm_results_get = _realm_results_getPtr.asFunction<
      bool Function(
          ffi.Pointer<realm_results_t>, int, ffi.Pointer<realm_value_t>)>();

  /// Returns an instance of realm_dictionary for the index passed as argument.
  /// @return A valid ptr to a dictionary instance or nullptr in case of errors
  ffi.Pointer<realm_dictionary_t> realm_results_get_dictionary(
    ffi.Pointer<realm_results_t> arg0,
    int index,
  ) {
    return _realm_results_get_dictionary(
      arg0,
      index,
    );
  }

  late final _realm_results_get_dictionaryPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<realm_dictionary_t> Function(ffi.Pointer<realm_results_t>,
              ffi.Size)>>('realm_results_get_dictionary');
  late final _realm_results_get_dictionary =
      _realm_results_get_dictionaryPtr.asFunction<
          ffi.Pointer<realm_dictionary_t> Function(
              ffi.Pointer<realm_results_t>, int)>();

  /// Returns an instance of realm_list at the index passed as argument.
  /// @return A valid ptr to a list instance or nullptr in case of errors
  ffi.Pointer<realm_list_t> realm_results_get_list(
    ffi.Pointer<realm_results_t> arg0,
    int index,
  ) {
    return _realm_results_get_list(
      arg0,
      index,
    );
  }

  late final _realm_results_get_listPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<realm_list_t> Function(ffi.Pointer<realm_results_t>,
              ffi.Size)>>('realm_results_get_list');
  late final _realm_results_get_list = _realm_results_get_listPtr.asFunction<
      ffi.Pointer<realm_list_t> Function(ffi.Pointer<realm_results_t>, int)>();

  /// Get the matching object at @a index in the results.
  ///
  /// If the result is "live" (not a snapshot), this may rerun the query if things
  /// have changed.
  ///
  /// Note: The bound returned by `realm_results_count()` for a non-snapshot result
  /// is not a reliable way to iterate over elements in the result, because
  /// the result will be live-updated if changes are made in each iteration
  /// that may change the number of query results or even change the
  /// ordering. In other words, this method should probably only be used with
  /// snapshot results.
  ///
  /// @return An instance of `realm_object_t` if no exception occurred.
  ffi.Pointer<realm_object_t> realm_results_get_object(
    ffi.Pointer<realm_results_t> arg0,
    int index,
  ) {
    return _realm_results_get_object(
      arg0,
      index,
    );
  }

  late final _realm_results_get_objectPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<realm_object_t> Function(ffi.Pointer<realm_results_t>,
              ffi.Size)>>('realm_results_get_object');
  late final _realm_results_get_object =
      _realm_results_get_objectPtr.asFunction<
          ffi.Pointer<realm_object_t> Function(
              ffi.Pointer<realm_results_t>, int)>();

  /// Return the query associated to the results passed as argument.
  ///
  /// @param results the ptr to a valid results object.
  /// @return a valid ptr to realm_query_t if no error has occurred
  ffi.Pointer<realm_query_t> realm_results_get_query(
    ffi.Pointer<realm_results_t> results,
  ) {
    return _realm_results_get_query(
      results,
    );
  }

  late final _realm_results_get_queryPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<realm_query_t> Function(
              ffi.Pointer<realm_results_t>)>>('realm_results_get_query');
  late final _realm_results_get_query = _realm_results_get_queryPtr.asFunction<
      ffi.Pointer<realm_query_t> Function(ffi.Pointer<realm_results_t>)>();

  /// Set the boolean passed as argument to true or false whether the realm_results passed is valid or not
  /// @return true/false if no exception has occurred.
  bool realm_results_is_valid(
    ffi.Pointer<realm_results_t> arg0,
    ffi.Pointer<ffi.Bool> arg1,
  ) {
    return _realm_results_is_valid(
      arg0,
      arg1,
    );
  }

  late final _realm_results_is_validPtr = _lookup<
      ffi.NativeFunction<
          ffi.Bool Function(ffi.Pointer<realm_results_t>,
              ffi.Pointer<ffi.Bool>)>>('realm_results_is_valid');
  late final _realm_results_is_valid = _realm_results_is_validPtr.asFunction<
      bool Function(ffi.Pointer<realm_results_t>, ffi.Pointer<ffi.Bool>)>();

  /// Create a new results object by limiting the number of items
  ///
  /// @param max_count Specifies the number of elements the new result can have at most
  /// @return A non-null pointer if no exception occurred.
  ffi.Pointer<realm_results_t> realm_results_limit(
    ffi.Pointer<realm_results_t> results,
    int max_count,
  ) {
    return _realm_results_limit(
      results,
      max_count,
    );
  }

  late final _realm_results_limitPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<realm_results_t> Function(
              ffi.Pointer<realm_results_t>, ffi.Size)>>('realm_results_limit');
  late final _realm_results_limit = _realm_results_limitPtr.asFunction<
      ffi.Pointer<realm_results_t> Function(
          ffi.Pointer<realm_results_t>, int)>();

  /// Compute the maximum value of a property in the results.
  ///
  /// @param out_max Where to write the result, if there were matching rows.
  /// @param out_found Set to true if there are matching rows.
  /// @return True if no exception occurred.
  bool realm_results_max(
    ffi.Pointer<realm_results_t> arg0,
    int arg1,
    ffi.Pointer<realm_value_t> out_max,
    ffi.Pointer<ffi.Bool> out_found,
  ) {
    return _realm_results_max(
      arg0,
      arg1,
      out_max,
      out_found,
    );
  }

  late final _realm_results_maxPtr = _lookup<
      ffi.NativeFunction<
          ffi.Bool Function(
              ffi.Pointer<realm_results_t>,
              realm_property_key_t,
              ffi.Pointer<realm_value_t>,
              ffi.Pointer<ffi.Bool>)>>('realm_results_max');
  late final _realm_results_max = _realm_results_maxPtr.asFunction<
      bool Function(ffi.Pointer<realm_results_t>, int,
          ffi.Pointer<realm_value_t>, ffi.Pointer<ffi.Bool>)>();

  /// Compute the minimum value of a property in the results.
  ///
  /// @param out_min Where to write the result, if there were matching rows.
  /// @param out_found Set to true if there are matching rows.
  /// @return True if no exception occurred.
  bool realm_results_min(
    ffi.Pointer<realm_results_t> arg0,
    int arg1,
    ffi.Pointer<realm_value_t> out_min,
    ffi.Pointer<ffi.Bool> out_found,
  ) {
    return _realm_results_min(
      arg0,
      arg1,
      out_min,
      out_found,
    );
  }

  late final _realm_results_minPtr = _lookup<
      ffi.NativeFunction<
          ffi.Bool Function(
              ffi.Pointer<realm_results_t>,
              realm_property_key_t,
              ffi.Pointer<realm_value_t>,
              ffi.Pointer<ffi.Bool>)>>('realm_results_min');
  late final _realm_results_min = _realm_results_minPtr.asFunction<
      bool Function(ffi.Pointer<realm_results_t>, int,
          ffi.Pointer<realm_value_t>, ffi.Pointer<ffi.Bool>)>();

  /// Map the Results into a live Realm instance.
  ///
  /// This is equivalent to producing a thread-safe reference and resolving it in the live realm.
  ///
  /// @return A live copy of the Results.
  ffi.Pointer<realm_results_t> realm_results_resolve_in(
    ffi.Pointer<realm_results_t> from_results,
    ffi.Pointer<realm_t> target_realm,
  ) {
    return _realm_results_resolve_in(
      from_results,
      target_realm,
    );
  }

  late final _realm_results_resolve_inPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<realm_results_t> Function(ffi.Pointer<realm_results_t>,
              ffi.Pointer<realm_t>)>>('realm_results_resolve_in');
  late final _realm_results_resolve_in =
      _realm_results_resolve_inPtr.asFunction<
          ffi.Pointer<realm_results_t> Function(
              ffi.Pointer<realm_results_t>, ffi.Pointer<realm_t>)>();

  /// Return a snapshot of the results that never automatically updates.
  ///
  /// The returned result is suitable for use with `realm_results_count()` +
  /// `realm_results_get()`.
  ffi.Pointer<realm_results_t> realm_results_snapshot(
    ffi.Pointer<realm_results_t> arg0,
  ) {
    return _realm_results_snapshot(
      arg0,
    );
  }

  late final _realm_results_snapshotPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<realm_results_t> Function(
              ffi.Pointer<realm_results_t>)>>('realm_results_snapshot');
  late final _realm_results_snapshot = _realm_results_snapshotPtr.asFunction<
      ffi.Pointer<realm_results_t> Function(ffi.Pointer<realm_results_t>)>();

  /// Create a new results object by further sorting existing result.
  ///
  /// @param sort_string Specifies a sort condition. It has the format
  /// <param> ["," <param>]*
  /// <param> ::= <prop> ["." <prop>]* <direction>,
  /// <direction> ::= "ASCENDING" | "DESCENDING"
  /// @return A non-null pointer if no exception occurred.
  ffi.Pointer<realm_results_t> realm_results_sort(
    ffi.Pointer<realm_results_t> results,
    ffi.Pointer<ffi.Char> sort_string,
  ) {
    return _realm_results_sort(
      results,
      sort_string,
    );
  }

  late final _realm_results_sortPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<realm_results_t> Function(ffi.Pointer<realm_results_t>,
              ffi.Pointer<ffi.Char>)>>('realm_results_sort');
  late final _realm_results_sort = _realm_results_sortPtr.asFunction<
      ffi.Pointer<realm_results_t> Function(
          ffi.Pointer<realm_results_t>, ffi.Pointer<ffi.Char>)>();

  /// Compute the sum value of a property in the results.
  ///
  /// @param out_sum Where to write the result. Zero if no rows matched.
  /// @param out_found Set to true if there are matching rows.
  /// @return True if no exception occurred.
  bool realm_results_sum(
    ffi.Pointer<realm_results_t> arg0,
    int arg1,
    ffi.Pointer<realm_value_t> out_sum,
    ffi.Pointer<ffi.Bool> out_found,
  ) {
    return _realm_results_sum(
      arg0,
      arg1,
      out_sum,
      out_found,
    );
  }

  late final _realm_results_sumPtr = _lookup<
      ffi.NativeFunction<
          ffi.Bool Function(
              ffi.Pointer<realm_results_t>,
              realm_property_key_t,
              ffi.Pointer<realm_value_t>,
              ffi.Pointer<ffi.Bool>)>>('realm_results_sum');
  late final _realm_results_sum = _realm_results_sumPtr.asFunction<
      bool Function(ffi.Pointer<realm_results_t>, int,
          ffi.Pointer<realm_value_t>, ffi.Pointer<ffi.Bool>)>();

  /// Roll back a write transaction.
  ///
  /// @return True if the rollback succeeded and no exceptions were thrown.
  bool realm_rollback(
    ffi.Pointer<realm_t> arg0,
  ) {
    return _realm_rollback(
      arg0,
    );
  }

  late final _realm_rollbackPtr =
      _lookup<ffi.NativeFunction<ffi.Bool Function(ffi.Pointer<realm_t>)>>(
          'realm_rollback');
  late final _realm_rollback =
      _realm_rollbackPtr.asFunction<bool Function(ffi.Pointer<realm_t>)>();

  /// Get the scheduler used by frozen realms. This scheduler does not support
  /// notifications, and does not perform any thread checking.
  ///
  /// This function is thread-safe, and cannot fail.
  ffi.Pointer<realm_scheduler_t> realm_scheduler_get_frozen() {
    return _realm_scheduler_get_frozen();
  }

  late final _realm_scheduler_get_frozenPtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<realm_scheduler_t> Function()>>(
          'realm_scheduler_get_frozen');
  late final _realm_scheduler_get_frozen = _realm_scheduler_get_frozenPtr
      .asFunction<ffi.Pointer<realm_scheduler_t> Function()>();

  /// Create an instance of the default scheduler for the current platform,
  /// normally confined to the calling thread.
  ffi.Pointer<realm_scheduler_t> realm_scheduler_make_default() {
    return _realm_scheduler_make_default();
  }

  late final _realm_scheduler_make_defaultPtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<realm_scheduler_t> Function()>>(
          'realm_scheduler_make_default');
  late final _realm_scheduler_make_default = _realm_scheduler_make_defaultPtr
      .asFunction<ffi.Pointer<realm_scheduler_t> Function()>();

  /// Create a custom scheduler object from callback functions.
  ///
  /// @param notify Function which will be called whenever the scheduler has work
  /// to do. Each call to this should trigger a call to
  /// `realm_scheduler_perform_work()` from within the scheduler's
  /// event loop. This function must be thread-safe, or NULL, in
  /// which case the scheduler is considered unable to deliver
  /// notifications.
  /// @param is_on_thread Function to return true if called from the same thread as
  /// the scheduler. This function must be thread-safe.
  /// @param can_deliver_notifications Function to return true if the scheduler can
  /// support `notify()`. This function does not
  /// need to be thread-safe.
  ffi.Pointer<realm_scheduler_t> realm_scheduler_new(
    ffi.Pointer<ffi.Void> userdata,
    realm_free_userdata_func_t userdata_free,
    realm_scheduler_notify_func_t notify,
    realm_scheduler_is_on_thread_func_t is_on_thread,
    realm_scheduler_is_same_as_func_t is_same_as,
    realm_scheduler_can_deliver_notifications_func_t can_deliver_notifications,
  ) {
    return _realm_scheduler_new(
      userdata,
      userdata_free,
      notify,
      is_on_thread,
      is_same_as,
      can_deliver_notifications,
    );
  }

  late final _realm_scheduler_newPtr = _lookup<
          ffi.NativeFunction<
              ffi.Pointer<realm_scheduler_t> Function(
                  ffi.Pointer<ffi.Void>,
                  realm_free_userdata_func_t,
                  realm_scheduler_notify_func_t,
                  realm_scheduler_is_on_thread_func_t,
                  realm_scheduler_is_same_as_func_t,
                  realm_scheduler_can_deliver_notifications_func_t)>>(
      'realm_scheduler_new');
  late final _realm_scheduler_new = _realm_scheduler_newPtr.asFunction<
      ffi.Pointer<realm_scheduler_t> Function(
          ffi.Pointer<ffi.Void>,
          realm_free_userdata_func_t,
          realm_scheduler_notify_func_t,
          realm_scheduler_is_on_thread_func_t,
          realm_scheduler_is_same_as_func_t,
          realm_scheduler_can_deliver_notifications_func_t)>();

  /// Performs all of the pending work for the given scheduler.
  ///
  /// This function must be called from within the scheduler's event loop. It must
  /// be called each time the notify callback passed to the scheduler
  /// is invoked.
  void realm_scheduler_perform_work(
    ffi.Pointer<realm_work_queue_t> arg0,
  ) {
    return _realm_scheduler_perform_work(
      arg0,
    );
  }

  late final _realm_scheduler_perform_workPtr = _lookup<
          ffi
          .NativeFunction<ffi.Void Function(ffi.Pointer<realm_work_queue_t>)>>(
      'realm_scheduler_perform_work');
  late final _realm_scheduler_perform_work = _realm_scheduler_perform_workPtr
      .asFunction<void Function(ffi.Pointer<realm_work_queue_t>)>();

  /// Create a new schema from classes and their properties.
  ///
  /// Note: This function does not validate the schema.
  ///
  /// Note: `realm_class_key_t` and `realm_property_key_t` values inside
  /// `realm_class_info_t` and `realm_property_info_t` are unused when
  /// defining the schema. Call `realm_get_schema()` to obtain the values for
  /// these fields in an open realm.
  ///
  /// @return True if allocation of the schema structure succeeded.
  ffi.Pointer<realm_schema_t> realm_schema_new(
    ffi.Pointer<realm_class_info_t> classes,
    int num_classes,
    ffi.Pointer<ffi.Pointer<realm_property_info_t>> class_properties,
  ) {
    return _realm_schema_new(
      classes,
      num_classes,
      class_properties,
    );
  }

  late final _realm_schema_newPtr = _lookup<
          ffi.NativeFunction<
              ffi.Pointer<realm_schema_t> Function(
                  ffi.Pointer<realm_class_info_t>,
                  ffi.Size,
                  ffi.Pointer<ffi.Pointer<realm_property_info_t>>)>>(
      'realm_schema_new');
  late final _realm_schema_new = _realm_schema_newPtr.asFunction<
      ffi.Pointer<realm_schema_t> Function(ffi.Pointer<realm_class_info_t>, int,
          ffi.Pointer<ffi.Pointer<realm_property_info_t>>)>();

  /// Rename a property for the schame  of the open realm.
  /// @param realm The realm for which the property schema has to be renamed
  /// @param schema The schema to modifies
  /// @param object_type type of the object to modify
  /// @param old_name old name of the property
  /// @param new_name new name of the property
  bool realm_schema_rename_property(
    ffi.Pointer<realm_t> realm,
    ffi.Pointer<realm_schema_t> schema,
    ffi.Pointer<ffi.Char> object_type,
    ffi.Pointer<ffi.Char> old_name,
    ffi.Pointer<ffi.Char> new_name,
  ) {
    return _realm_schema_rename_property(
      realm,
      schema,
      object_type,
      old_name,
      new_name,
    );
  }

  late final _realm_schema_rename_propertyPtr = _lookup<
      ffi.NativeFunction<
          ffi.Bool Function(
              ffi.Pointer<realm_t>,
              ffi.Pointer<realm_schema_t>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>)>>('realm_schema_rename_property');
  late final _realm_schema_rename_property =
      _realm_schema_rename_propertyPtr.asFunction<
          bool Function(
              ffi.Pointer<realm_t>,
              ffi.Pointer<realm_schema_t>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>)>();

  /// Validate the schema.
  ///
  /// @param validation_mode A bitwise combination of values from the
  /// enum realm_schema_validation_mode.
  ///
  /// @return True if the schema passed validation. If validation failed,
  /// `realm_get_last_error()` will produce an error describing the
  /// validation failure.
  bool realm_schema_validate(
    ffi.Pointer<realm_schema_t> arg0,
    int validation_mode,
  ) {
    return _realm_schema_validate(
      arg0,
      validation_mode,
    );
  }

  late final _realm_schema_validatePtr = _lookup<
      ffi.NativeFunction<
          ffi.Bool Function(ffi.Pointer<realm_schema_t>,
              ffi.Uint64)>>('realm_schema_validate');
  late final _realm_schema_validate = _realm_schema_validatePtr
      .asFunction<bool Function(ffi.Pointer<realm_schema_t>, int)>();

  /// Subscribe to notifications for this object.
  ///
  /// @return A non-null pointer if no exception occurred.
  ffi.Pointer<realm_notification_token_t> realm_set_add_notification_callback(
    ffi.Pointer<realm_set_t> arg0,
    ffi.Pointer<ffi.Void> userdata,
    realm_free_userdata_func_t userdata_free,
    ffi.Pointer<realm_key_path_array_t> key_path_array,
    realm_on_collection_change_func_t on_change,
  ) {
    return _realm_set_add_notification_callback(
      arg0,
      userdata,
      userdata_free,
      key_path_array,
      on_change,
    );
  }

  late final _realm_set_add_notification_callbackPtr = _lookup<
          ffi.NativeFunction<
              ffi.Pointer<realm_notification_token_t> Function(
                  ffi.Pointer<realm_set_t>,
                  ffi.Pointer<ffi.Void>,
                  realm_free_userdata_func_t,
                  ffi.Pointer<realm_key_path_array_t>,
                  realm_on_collection_change_func_t)>>(
      'realm_set_add_notification_callback');
  late final _realm_set_add_notification_callback =
      _realm_set_add_notification_callbackPtr.asFunction<
          ffi.Pointer<realm_notification_token_t> Function(
              ffi.Pointer<realm_set_t>,
              ffi.Pointer<ffi.Void>,
              realm_free_userdata_func_t,
              ffi.Pointer<realm_key_path_array_t>,
              realm_on_collection_change_func_t)>();

  void realm_set_auto_refresh(
    ffi.Pointer<realm_t> realm,
    bool enable,
  ) {
    return _realm_set_auto_refresh(
      realm,
      enable,
    );
  }

  late final _realm_set_auto_refreshPtr = _lookup<
          ffi
          .NativeFunction<ffi.Void Function(ffi.Pointer<realm_t>, ffi.Bool)>>(
      'realm_set_auto_refresh');
  late final _realm_set_auto_refresh = _realm_set_auto_refreshPtr
      .asFunction<void Function(ffi.Pointer<realm_t>, bool)>();

  /// Clear a set of values.
  ///
  /// @return True if no exception occurred.
  bool realm_set_clear(
    ffi.Pointer<realm_set_t> arg0,
  ) {
    return _realm_set_clear(
      arg0,
    );
  }

  late final _realm_set_clearPtr =
      _lookup<ffi.NativeFunction<ffi.Bool Function(ffi.Pointer<realm_set_t>)>>(
          'realm_set_clear');
  late final _realm_set_clear =
      _realm_set_clearPtr.asFunction<bool Function(ffi.Pointer<realm_set_t>)>();

  ffi.Pointer<realm_dictionary_t> realm_set_dictionary(
    ffi.Pointer<realm_object_t> arg0,
    int arg1,
  ) {
    return _realm_set_dictionary(
      arg0,
      arg1,
    );
  }

  late final _realm_set_dictionaryPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<realm_dictionary_t> Function(ffi.Pointer<realm_object_t>,
              realm_property_key_t)>>('realm_set_dictionary');
  late final _realm_set_dictionary = _realm_set_dictionaryPtr.asFunction<
      ffi.Pointer<realm_dictionary_t> Function(
          ffi.Pointer<realm_object_t>, int)>();

  /// Create an embedded object in a given property.
  ///
  /// @return A non-NULL pointer if the object was created successfully.
  ffi.Pointer<realm_object_t> realm_set_embedded(
    ffi.Pointer<realm_object_t> arg0,
    int arg1,
  ) {
    return _realm_set_embedded(
      arg0,
      arg1,
    );
  }

  late final _realm_set_embeddedPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<realm_object_t> Function(ffi.Pointer<realm_object_t>,
              realm_property_key_t)>>('realm_set_embedded');
  late final _realm_set_embedded = _realm_set_embeddedPtr.asFunction<
      ffi.Pointer<realm_object_t> Function(ffi.Pointer<realm_object_t>, int)>();

  /// Erase an element from a set.
  ///
  /// If the element does not exist in the set, this function does nothing (and
  /// does not report an error).
  ///
  /// @param value The value to erase.
  /// @param out_erased If non-null, will be set to true if the element was found
  /// and erased, and otherwise set to false.
  /// @return True if no exception occurred.
  bool realm_set_erase(
    ffi.Pointer<realm_set_t> arg0,
    realm_value_t value,
    ffi.Pointer<ffi.Bool> out_erased,
  ) {
    return _realm_set_erase(
      arg0,
      value,
      out_erased,
    );
  }

  late final _realm_set_erasePtr = _lookup<
      ffi.NativeFunction<
          ffi.Bool Function(ffi.Pointer<realm_set_t>, realm_value_t,
              ffi.Pointer<ffi.Bool>)>>('realm_set_erase');
  late final _realm_set_erase = _realm_set_erasePtr.asFunction<
      bool Function(
          ffi.Pointer<realm_set_t>, realm_value_t, ffi.Pointer<ffi.Bool>)>();

  /// Find an element in a set.
  ///
  /// If @a value has a type that is incompatible with the set, it will be reported
  /// as not existing in the set.
  ///
  /// @param value The value to look for in the set.
  /// @param out_index If non-null, and the element is found, this will be
  /// populated with the index of the found element in the set.
  /// @param out_found If non-null, will be set to true if the element was found,
  /// otherwise will be set to false.
  /// @return True if no exception occurred.
  bool realm_set_find(
    ffi.Pointer<realm_set_t> arg0,
    realm_value_t value,
    ffi.Pointer<ffi.Size> out_index,
    ffi.Pointer<ffi.Bool> out_found,
  ) {
    return _realm_set_find(
      arg0,
      value,
      out_index,
      out_found,
    );
  }

  late final _realm_set_findPtr = _lookup<
      ffi.NativeFunction<
          ffi.Bool Function(ffi.Pointer<realm_set_t>, realm_value_t,
              ffi.Pointer<ffi.Size>, ffi.Pointer<ffi.Bool>)>>('realm_set_find');
  late final _realm_set_find = _realm_set_findPtr.asFunction<
      bool Function(ffi.Pointer<realm_set_t>, realm_value_t,
          ffi.Pointer<ffi.Size>, ffi.Pointer<ffi.Bool>)>();

  /// Get an set from a thread-safe reference, potentially originating in a
  /// different `realm_t` instance
  ffi.Pointer<realm_set_t> realm_set_from_thread_safe_reference(
    ffi.Pointer<realm_t> arg0,
    ffi.Pointer<realm_thread_safe_reference_t> arg1,
  ) {
    return _realm_set_from_thread_safe_reference(
      arg0,
      arg1,
    );
  }

  late final _realm_set_from_thread_safe_referencePtr = _lookup<
          ffi.NativeFunction<
              ffi.Pointer<realm_set_t> Function(ffi.Pointer<realm_t>,
                  ffi.Pointer<realm_thread_safe_reference_t>)>>(
      'realm_set_from_thread_safe_reference');
  late final _realm_set_from_thread_safe_reference =
      _realm_set_from_thread_safe_referencePtr.asFunction<
          ffi.Pointer<realm_set_t> Function(ffi.Pointer<realm_t>,
              ffi.Pointer<realm_thread_safe_reference_t>)>();

  /// Get the value at @a index.
  ///
  /// Note that elements in a set move around arbitrarily when other elements are
  /// inserted/removed.
  ///
  /// @param out_value The resulting value, if no error occurred. May be NULL,
  /// though nonsensical.
  /// @return True if no exception occurred.
  bool realm_set_get(
    ffi.Pointer<realm_set_t> arg0,
    int index,
    ffi.Pointer<realm_value_t> out_value,
  ) {
    return _realm_set_get(
      arg0,
      index,
      out_value,
    );
  }

  late final _realm_set_getPtr = _lookup<
      ffi.NativeFunction<
          ffi.Bool Function(ffi.Pointer<realm_set_t>, ffi.Size,
              ffi.Pointer<realm_value_t>)>>('realm_set_get');
  late final _realm_set_get = _realm_set_getPtr.asFunction<
      bool Function(
          ffi.Pointer<realm_set_t>, int, ffi.Pointer<realm_value_t>)>();

  /// Get the property that this set came from.
  ///
  /// @return True if no exception occurred.
  bool realm_set_get_property(
    ffi.Pointer<realm_set_t> arg0,
    ffi.Pointer<realm_property_info_t> out_property_info,
  ) {
    return _realm_set_get_property(
      arg0,
      out_property_info,
    );
  }

  late final _realm_set_get_propertyPtr = _lookup<
      ffi.NativeFunction<
          ffi.Bool Function(ffi.Pointer<realm_set_t>,
              ffi.Pointer<realm_property_info_t>)>>('realm_set_get_property');
  late final _realm_set_get_property = _realm_set_get_propertyPtr.asFunction<
      bool Function(
          ffi.Pointer<realm_set_t>, ffi.Pointer<realm_property_info_t>)>();

  /// Insert an element in a set.
  ///
  /// If the element is already in the set, this function does nothing (and does
  /// not report an error).
  ///
  /// @param value The value to insert.
  /// @param out_index If non-null, will be set to the index of the inserted
  /// element, or the index of the existing element.
  /// @param out_inserted If non-null, will be set to true if the element did not
  /// already exist in the set. Otherwise set to false.
  /// @return True if no exception occurred.
  bool realm_set_insert(
    ffi.Pointer<realm_set_t> arg0,
    realm_value_t value,
    ffi.Pointer<ffi.Size> out_index,
    ffi.Pointer<ffi.Bool> out_inserted,
  ) {
    return _realm_set_insert(
      arg0,
      value,
      out_index,
      out_inserted,
    );
  }

  late final _realm_set_insertPtr = _lookup<
      ffi.NativeFunction<
          ffi.Bool Function(
              ffi.Pointer<realm_set_t>,
              realm_value_t,
              ffi.Pointer<ffi.Size>,
              ffi.Pointer<ffi.Bool>)>>('realm_set_insert');
  late final _realm_set_insert = _realm_set_insertPtr.asFunction<
      bool Function(ffi.Pointer<realm_set_t>, realm_value_t,
          ffi.Pointer<ffi.Size>, ffi.Pointer<ffi.Bool>)>();

  /// Check if a set is valid.
  ///
  /// @return True if the set is valid.
  bool realm_set_is_valid(
    ffi.Pointer<realm_set_t> arg0,
  ) {
    return _realm_set_is_valid(
      arg0,
    );
  }

  late final _realm_set_is_validPtr =
      _lookup<ffi.NativeFunction<ffi.Bool Function(ffi.Pointer<realm_set_t>)>>(
          'realm_set_is_valid');
  late final _realm_set_is_valid = _realm_set_is_validPtr
      .asFunction<bool Function(ffi.Pointer<realm_set_t>)>();

  /// Assign a JSON formatted string to a Mixed property. Underlying structures will be created as needed
  ///
  /// @param json_string The new value for the property.
  /// @return True if no exception occurred.
  bool realm_set_json(
    ffi.Pointer<realm_object_t> arg0,
    int arg1,
    ffi.Pointer<ffi.Char> json_string,
  ) {
    return _realm_set_json(
      arg0,
      arg1,
      json_string,
    );
  }

  late final _realm_set_jsonPtr = _lookup<
      ffi.NativeFunction<
          ffi.Bool Function(ffi.Pointer<realm_object_t>, realm_property_key_t,
              ffi.Pointer<ffi.Char>)>>('realm_set_json');
  late final _realm_set_json = _realm_set_jsonPtr.asFunction<
      bool Function(ffi.Pointer<realm_object_t>, int, ffi.Pointer<ffi.Char>)>();

  /// Create a collection in a given Mixed property.
  ffi.Pointer<realm_list_t> realm_set_list(
    ffi.Pointer<realm_object_t> arg0,
    int arg1,
  ) {
    return _realm_set_list(
      arg0,
      arg1,
    );
  }

  late final _realm_set_listPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<realm_list_t> Function(ffi.Pointer<realm_object_t>,
              realm_property_key_t)>>('realm_set_list');
  late final _realm_set_list = _realm_set_listPtr.asFunction<
      ffi.Pointer<realm_list_t> Function(ffi.Pointer<realm_object_t>, int)>();

  /// Install the default logger
  void realm_set_log_callback(
    realm_log_func_t arg0,
    ffi.Pointer<ffi.Void> userdata,
    realm_free_userdata_func_t userdata_free,
  ) {
    return _realm_set_log_callback(
      arg0,
      userdata,
      userdata_free,
    );
  }

  late final _realm_set_log_callbackPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(realm_log_func_t, ffi.Pointer<ffi.Void>,
              realm_free_userdata_func_t)>>('realm_set_log_callback');
  late final _realm_set_log_callback = _realm_set_log_callbackPtr.asFunction<
      void Function(realm_log_func_t, ffi.Pointer<ffi.Void>,
          realm_free_userdata_func_t)>();

  void realm_set_log_level(
    realm_log_level arg0,
  ) {
    return _realm_set_log_level(
      arg0.value,
    );
  }

  late final _realm_set_log_levelPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.UnsignedInt)>>(
          'realm_set_log_level');
  late final _realm_set_log_level =
      _realm_set_log_levelPtr.asFunction<void Function(int)>();

  /// Set the logging level for given category. Return the previous level.
  realm_log_level realm_set_log_level_category(
    ffi.Pointer<ffi.Char> arg0,
    realm_log_level arg1,
  ) {
    return realm_log_level.fromValue(_realm_set_log_level_category(
      arg0,
      arg1.value,
    ));
  }

  late final _realm_set_log_level_categoryPtr = _lookup<
      ffi.NativeFunction<
          ffi.UnsignedInt Function(ffi.Pointer<ffi.Char>,
              ffi.UnsignedInt)>>('realm_set_log_level_category');
  late final _realm_set_log_level_category = _realm_set_log_level_categoryPtr
      .asFunction<int Function(ffi.Pointer<ffi.Char>, int)>();

  /// In a set of objects, delete all objects in the set and clear the set. In a
  /// set of values, clear the set.
  ///
  /// @return True if no exception occurred.
  bool realm_set_remove_all(
    ffi.Pointer<realm_set_t> arg0,
  ) {
    return _realm_set_remove_all(
      arg0,
    );
  }

  late final _realm_set_remove_allPtr =
      _lookup<ffi.NativeFunction<ffi.Bool Function(ffi.Pointer<realm_set_t>)>>(
          'realm_set_remove_all');
  late final _realm_set_remove_all = _realm_set_remove_allPtr
      .asFunction<bool Function(ffi.Pointer<realm_set_t>)>();

  /// Resolve the set in the context of a given Realm instance.
  ///
  /// This is equivalent to producing a thread-safe reference and resolving it in the frozen realm.
  ///
  /// If resolution is possible, a valid resolved object is produced at '*resolved*'.
  /// If resolution is not possible, but no error occurs, '*resolved' is set to NULL
  ///
  /// @return true if no error occurred.
  bool realm_set_resolve_in(
    ffi.Pointer<realm_set_t> list,
    ffi.Pointer<realm_t> target_realm,
    ffi.Pointer<ffi.Pointer<realm_set_t>> resolved,
  ) {
    return _realm_set_resolve_in(
      list,
      target_realm,
      resolved,
    );
  }

  late final _realm_set_resolve_inPtr = _lookup<
      ffi.NativeFunction<
          ffi.Bool Function(ffi.Pointer<realm_set_t>, ffi.Pointer<realm_t>,
              ffi.Pointer<ffi.Pointer<realm_set_t>>)>>('realm_set_resolve_in');
  late final _realm_set_resolve_in = _realm_set_resolve_inPtr.asFunction<
      bool Function(ffi.Pointer<realm_set_t>, ffi.Pointer<realm_t>,
          ffi.Pointer<ffi.Pointer<realm_set_t>>)>();

  /// Get the size of a set, in number of unique elements.
  ///
  /// This function may fail if the object owning the set has been deleted.
  ///
  /// @param out_size Where to put the set size. May be NULL.
  /// @return True if no exception occurred.
  bool realm_set_size(
    ffi.Pointer<realm_set_t> arg0,
    ffi.Pointer<ffi.Size> out_size,
  ) {
    return _realm_set_size(
      arg0,
      out_size,
    );
  }

  late final _realm_set_sizePtr = _lookup<
      ffi.NativeFunction<
          ffi.Bool Function(ffi.Pointer<realm_set_t>,
              ffi.Pointer<ffi.Size>)>>('realm_set_size');
  late final _realm_set_size = _realm_set_sizePtr.asFunction<
      bool Function(ffi.Pointer<realm_set_t>, ffi.Pointer<ffi.Size>)>();

  /// Convert a set to results.
  ///
  /// @return A non-null pointer if no exception occurred.
  ffi.Pointer<realm_results_t> realm_set_to_results(
    ffi.Pointer<realm_set_t> arg0,
  ) {
    return _realm_set_to_results(
      arg0,
    );
  }

  late final _realm_set_to_resultsPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<realm_results_t> Function(
              ffi.Pointer<realm_set_t>)>>('realm_set_to_results');
  late final _realm_set_to_results = _realm_set_to_resultsPtr.asFunction<
      ffi.Pointer<realm_results_t> Function(ffi.Pointer<realm_set_t>)>();

  /// Set the value for a property.
  ///
  /// @param new_value The new value for the property.
  /// @param is_default True if this property is being set as part of setting the
  /// default values for a new object. This has no effect in
  /// non-sync'ed realms.
  /// @return True if no exception occurred.
  bool realm_set_value(
    ffi.Pointer<realm_object_t> arg0,
    int arg1,
    realm_value_t new_value,
    bool is_default,
  ) {
    return _realm_set_value(
      arg0,
      arg1,
      new_value,
      is_default,
    );
  }

  late final _realm_set_valuePtr = _lookup<
      ffi.NativeFunction<
          ffi.Bool Function(ffi.Pointer<realm_object_t>, realm_property_key_t,
              realm_value_t, ffi.Bool)>>('realm_set_value');
  late final _realm_set_value = _realm_set_valuePtr.asFunction<
      bool Function(ffi.Pointer<realm_object_t>, int, realm_value_t, bool)>();

  /// Set the values for several properties.
  ///
  /// This is provided as an alternative to calling `realm_get_value()` multiple
  /// times in a row, which is particularly useful for language runtimes where
  /// crossing the native bridge is comparatively expensive. In addition, it
  /// eliminates some parameter validation that would otherwise be repeated for
  /// each call.
  ///
  /// Example use cases:
  ///
  /// - Initializing a new object with default values.
  /// - Deserializing some in-memory structure into a realm object.
  ///
  /// This operation is "atomic"; if an exception occurs due to invalid input (such
  /// as type mismatch, nullability mismatch, etc.), the object will remain
  /// unmodified.
  ///
  /// @param num_values The number of elements in @a properties and @a values.
  /// @param properties The keys of the properties to set. May not be NULL.
  /// @param values The values to assign to the properties. May not be NULL.
  /// @param is_default True if the properties are being set as part of setting
  /// default values for a new object. This has no effect in
  /// non-sync'ed realms.
  /// @return True if no exception occurred.
  bool realm_set_values(
    ffi.Pointer<realm_object_t> arg0,
    int num_values,
    ffi.Pointer<realm_property_key_t> properties,
    ffi.Pointer<realm_value_t> values,
    bool is_default,
  ) {
    return _realm_set_values(
      arg0,
      num_values,
      properties,
      values,
      is_default,
    );
  }

  late final _realm_set_valuesPtr = _lookup<
      ffi.NativeFunction<
          ffi.Bool Function(
              ffi.Pointer<realm_object_t>,
              ffi.Size,
              ffi.Pointer<realm_property_key_t>,
              ffi.Pointer<realm_value_t>,
              ffi.Bool)>>('realm_set_values');
  late final _realm_set_values = _realm_set_valuesPtr.asFunction<
      bool Function(
          ffi.Pointer<realm_object_t>,
          int,
          ffi.Pointer<realm_property_key_t>,
          ffi.Pointer<realm_value_t>,
          bool)>();

  /// Update the schema of an open realm.
  ///
  /// This is equivalent to calling `realm_update_schema_advanced(realm, schema, 0,
  /// NULL, NULL, NULL, NULL, false)`.
  bool realm_update_schema(
    ffi.Pointer<realm_t> realm,
    ffi.Pointer<realm_schema_t> schema,
  ) {
    return _realm_update_schema(
      realm,
      schema,
    );
  }

  late final _realm_update_schemaPtr = _lookup<
      ffi.NativeFunction<
          ffi.Bool Function(ffi.Pointer<realm_t>,
              ffi.Pointer<realm_schema_t>)>>('realm_update_schema');
  late final _realm_update_schema = _realm_update_schemaPtr.asFunction<
      bool Function(ffi.Pointer<realm_t>, ffi.Pointer<realm_schema_t>)>();

  /// Update the schema of an open realm, with options to customize certain steps
  /// of the process.
  ///
  /// @param realm The realm for which the schema should be updated.
  /// @param schema The new schema for the realm. If the schema is the same the
  /// existing schema, this function does nothing.
  /// @param version The version of the new schema.
  /// @param migration_func Callback to perform the migration. Has no effect if the
  /// Realm is opened with `RLM_SCHEMA_MODE_ADDITIVE`.
  /// @param migration_func_userdata Userdata pointer to pass to `migration_func`.
  /// @param data_init_func Callback to perform initialization of the data in the
  /// Realm if it is opened for the first time (i.e., it has
  /// no previous schema version).
  /// @param data_init_func_userdata Userdata pointer to pass to `data_init_func`.
  /// @param is_in_transaction Pass true if the realm is already in a write
  /// transaction. Otherwise, if the migration requires a
  /// write transaction, this function will perform the
  /// migration in its own write transaction.
  bool realm_update_schema_advanced(
    ffi.Pointer<realm_t> realm,
    ffi.Pointer<realm_schema_t> schema,
    int version,
    realm_migration_func_t migration_func,
    ffi.Pointer<ffi.Void> migration_func_userdata,
    realm_data_initialization_func_t data_init_func,
    ffi.Pointer<ffi.Void> data_init_func_userdata,
    bool is_in_transaction,
  ) {
    return _realm_update_schema_advanced(
      realm,
      schema,
      version,
      migration_func,
      migration_func_userdata,
      data_init_func,
      data_init_func_userdata,
      is_in_transaction,
    );
  }

  late final _realm_update_schema_advancedPtr = _lookup<
      ffi.NativeFunction<
          ffi.Bool Function(
              ffi.Pointer<realm_t>,
              ffi.Pointer<realm_schema_t>,
              ffi.Uint64,
              realm_migration_func_t,
              ffi.Pointer<ffi.Void>,
              realm_data_initialization_func_t,
              ffi.Pointer<ffi.Void>,
              ffi.Bool)>>('realm_update_schema_advanced');
  late final _realm_update_schema_advanced =
      _realm_update_schema_advancedPtr.asFunction<
          bool Function(
              ffi.Pointer<realm_t>,
              ffi.Pointer<realm_schema_t>,
              int,
              realm_migration_func_t,
              ffi.Pointer<ffi.Void>,
              realm_data_initialization_func_t,
              ffi.Pointer<ffi.Void>,
              bool)>();

  late final addresses = _SymbolAddresses(this);
}

class _SymbolAddresses {
  final RealmLibrary _library;
  _SymbolAddresses(this._library);
  ffi.Pointer<ffi.NativeFunction<ffi.Void Function(Dart_Port)>>
      get realm_dart_attach_logger => _library._realm_dart_attach_loggerPtr;
  ffi.Pointer<
          ffi.NativeFunction<
              ffi.Pointer<realm_scheduler_t> Function(ffi.Uint64, Dart_Port)>>
      get realm_dart_create_scheduler =>
          _library._realm_dart_create_schedulerPtr;
  ffi.Pointer<
          ffi.NativeFunction<
              realm_decimal128_t Function(
                  realm_decimal128_t, realm_decimal128_t)>>
      get realm_dart_decimal128_add => _library._realm_dart_decimal128_addPtr;
  ffi.Pointer<
          ffi.NativeFunction<
              ffi.Int Function(realm_decimal128_t, realm_decimal128_t)>>
      get realm_dart_decimal128_compare_to =>
          _library._realm_dart_decimal128_compare_toPtr;
  ffi.Pointer<
          ffi.NativeFunction<realm_decimal128_t Function(realm_decimal128_t)>>
      get realm_dart_decimal128_copy => _library._realm_dart_decimal128_copyPtr;
  ffi.Pointer<
          ffi.NativeFunction<
              realm_decimal128_t Function(
                  realm_decimal128_t, realm_decimal128_t)>>
      get realm_dart_decimal128_divide =>
          _library._realm_dart_decimal128_dividePtr;
  ffi.Pointer<
          ffi.NativeFunction<
              ffi.Bool Function(realm_decimal128_t, realm_decimal128_t)>>
      get realm_dart_decimal128_equal =>
          _library._realm_dart_decimal128_equalPtr;
  ffi.Pointer<ffi.NativeFunction<realm_decimal128_t Function(ffi.Int64)>>
      get realm_dart_decimal128_from_int64 =>
          _library._realm_dart_decimal128_from_int64Ptr;
  ffi.Pointer<
          ffi
          .NativeFunction<realm_decimal128_t Function(ffi.Pointer<ffi.Char>)>>
      get realm_dart_decimal128_from_string =>
          _library._realm_dart_decimal128_from_stringPtr;
  ffi.Pointer<
          ffi.NativeFunction<
              ffi.Bool Function(realm_decimal128_t, realm_decimal128_t)>>
      get realm_dart_decimal128_greater_than =>
          _library._realm_dart_decimal128_greater_thanPtr;
  ffi.Pointer<ffi.NativeFunction<ffi.Bool Function(realm_decimal128_t)>>
      get realm_dart_decimal128_is_nan =>
          _library._realm_dart_decimal128_is_nanPtr;
  ffi.Pointer<
          ffi.NativeFunction<
              ffi.Bool Function(realm_decimal128_t, realm_decimal128_t)>>
      get realm_dart_decimal128_less_than =>
          _library._realm_dart_decimal128_less_thanPtr;
  ffi.Pointer<
          ffi.NativeFunction<
              realm_decimal128_t Function(
                  realm_decimal128_t, realm_decimal128_t)>>
      get realm_dart_decimal128_multiply =>
          _library._realm_dart_decimal128_multiplyPtr;
  ffi.Pointer<ffi.NativeFunction<realm_decimal128_t Function()>>
      get realm_dart_decimal128_nan => _library._realm_dart_decimal128_nanPtr;
  ffi.Pointer<
          ffi.NativeFunction<realm_decimal128_t Function(realm_decimal128_t)>>
      get realm_dart_decimal128_negate =>
          _library._realm_dart_decimal128_negatePtr;
  ffi.Pointer<
          ffi.NativeFunction<
              realm_decimal128_t Function(
                  realm_decimal128_t, realm_decimal128_t)>>
      get realm_dart_decimal128_subtract =>
          _library._realm_dart_decimal128_subtractPtr;
  ffi.Pointer<ffi.NativeFunction<ffi.Int64 Function(realm_decimal128_t)>>
      get realm_dart_decimal128_to_int64 =>
          _library._realm_dart_decimal128_to_int64Ptr;
  ffi.Pointer<ffi.NativeFunction<realm_string_t Function(realm_decimal128_t)>>
      get realm_dart_decimal128_to_string =>
          _library._realm_dart_decimal128_to_stringPtr;
  ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>
      get realm_dart_delete_persistent_handle =>
          _library._realm_dart_delete_persistent_handlePtr;
  ffi.Pointer<ffi.NativeFunction<ffi.Void Function(Dart_Port)>>
      get realm_dart_detach_logger => _library._realm_dart_detach_loggerPtr;
  ffi.Pointer<ffi.NativeFunction<ffi.Pointer<ffi.Char> Function()>>
      get realm_dart_get_bundle_id => _library._realm_dart_get_bundle_idPtr;
  ffi.Pointer<ffi.NativeFunction<ffi.Pointer<ffi.Char> Function()>>
      get realm_dart_get_device_name => _library._realm_dart_get_device_namePtr;
  ffi.Pointer<ffi.NativeFunction<ffi.Pointer<ffi.Char> Function()>>
      get realm_dart_get_device_version =>
          _library._realm_dart_get_device_versionPtr;
  ffi.Pointer<ffi.NativeFunction<ffi.Pointer<ffi.Char> Function()>>
      get realm_dart_get_files_path => _library._realm_dart_get_files_pathPtr;
  ffi.Pointer<ffi.NativeFunction<ffi.Uint64 Function()>>
      get realm_dart_get_thread_id => _library._realm_dart_get_thread_idPtr;
  ffi.Pointer<ffi.NativeFunction<ffi.Void Function()>>
      get realm_dart_init_debug_logger =>
          _library._realm_dart_init_debug_loggerPtr;
  ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>
      get realm_dart_initializeDartApiDL =>
          _library._realm_dart_initializeDartApiDLPtr;
  ffi.Pointer<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>
      get realm_dart_invoke_unlock_callback =>
          _library._realm_dart_invoke_unlock_callbackPtr;
  ffi.Pointer<ffi.NativeFunction<ffi.Pointer<ffi.Char> Function()>>
      get realm_dart_library_version => _library._realm_dart_library_versionPtr;
  ffi.Pointer<
      ffi.NativeFunction<
          ffi.Void Function(ffi.UnsignedInt, ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>)>> get realm_dart_log =>
      _library._realm_dart_logPtr;
  ffi.Pointer<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function(ffi.Handle)>>
      get realm_dart_object_to_persistent_handle =>
          _library._realm_dart_object_to_persistent_handlePtr;
  ffi.Pointer<ffi.NativeFunction<ffi.Handle Function(ffi.Pointer<ffi.Void>)>>
      get realm_dart_persistent_handle_to_object =>
          _library._realm_dart_persistent_handle_to_objectPtr;
  ffi.Pointer<
          ffi
          .NativeFunction<ffi.Void Function(ffi.Uint64, ffi.Pointer<ffi.Void>)>>
      get realm_dart_scheduler_invoke =>
          _library._realm_dart_scheduler_invokePtr;
  ffi.Pointer<
          ffi
          .NativeFunction<ffi.Bool Function(ffi.Long, ffi.Pointer<ffi.Long>)>>
      get realm_dart_set_and_get_rlimit =>
          _library._realm_dart_set_and_get_rlimitPtr;
  ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>
      get realm_dart_userdata_async_free =>
          _library._realm_dart_userdata_async_freePtr;
  ffi.Pointer<
          ffi.NativeFunction<
              realm_dart_userdata_async_t Function(ffi.Handle,
                  ffi.Pointer<ffi.Void>, ffi.Pointer<realm_scheduler_t>)>>
      get realm_dart_userdata_async_new =>
          _library._realm_dart_userdata_async_newPtr;
  ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>
      get realm_release => _library._realm_releasePtr;
}

/// A port is used to send or receive inter-isolate messages
typedef Dart_Port = ffi.Int64;
typedef DartDart_Port = int;

final class UnnamedUnion1 extends ffi.Union {
  @ffi.Int64()
  external int integer;

  @ffi.Bool()
  external bool boolean;

  external realm_string_t string;

  external realm_binary_t binary;

  external realm_timestamp_t timestamp;

  @ffi.Float()
  external double fnum;

  @ffi.Double()
  external double dnum;

  external realm_decimal128_t decimal128;

  external realm_object_id_t object_id;

  external realm_uuid_t uuid;

  external realm_link_t link;

  @ffi.Array.multi([16])
  external ffi.Array<ffi.Char> data;
}

typedef realm_async_begin_write_func_t
    = ffi.Pointer<ffi.NativeFunction<realm_async_begin_write_func_tFunction>>;
typedef realm_async_begin_write_func_tFunction = ffi.Void Function(
    ffi.Pointer<ffi.Void> userdata);
typedef Dartrealm_async_begin_write_func_tFunction = void Function(
    ffi.Pointer<ffi.Void> userdata);
typedef realm_async_commit_func_t
    = ffi.Pointer<ffi.NativeFunction<realm_async_commit_func_tFunction>>;
typedef realm_async_commit_func_tFunction = ffi.Void Function(
    ffi.Pointer<ffi.Void> userdata, ffi.Bool error, ffi.Pointer<ffi.Char> desc);
typedef Dartrealm_async_commit_func_tFunction = void Function(
    ffi.Pointer<ffi.Void> userdata, bool error, ffi.Pointer<ffi.Char> desc);

final class realm_async_error extends ffi.Opaque {}

/// Error types
typedef realm_async_error_t = realm_async_error;

final class realm_binary extends ffi.Struct {
  external ffi.Pointer<ffi.Uint8> data;

  @ffi.Size()
  external int size;
}

typedef realm_binary_t = realm_binary;

final class realm_callback_token extends ffi.Opaque {}

typedef realm_callback_token_t = realm_callback_token;

enum realm_class_flags {
  RLM_CLASS_NORMAL(0),
  RLM_CLASS_EMBEDDED(1),
  RLM_CLASS_ASYMMETRIC(2),
  RLM_CLASS_MASK(3);

  final int value;
  const realm_class_flags(this.value);

  static realm_class_flags fromValue(int value) => switch (value) {
        0 => RLM_CLASS_NORMAL,
        1 => RLM_CLASS_EMBEDDED,
        2 => RLM_CLASS_ASYMMETRIC,
        3 => RLM_CLASS_MASK,
        _ => throw ArgumentError("Unknown value for realm_class_flags: $value"),
      };
}

final class realm_class_info extends ffi.Struct {
  external ffi.Pointer<ffi.Char> name;

  external ffi.Pointer<ffi.Char> primary_key;

  @ffi.Size()
  external int num_properties;

  @ffi.Size()
  external int num_computed_properties;

  @realm_class_key_t()
  external int key;

  @ffi.Int()
  external int flags;
}

typedef realm_class_info_t = realm_class_info;

/// Key types
typedef realm_class_key_t = ffi.Uint32;
typedef Dartrealm_class_key_t = int;

final class realm_collection_changes extends ffi.Opaque {}

typedef realm_collection_changes_t = realm_collection_changes;

final class realm_collection_move extends ffi.Struct {
  @ffi.Size()
  external int from;

  @ffi.Size()
  external int to;
}

typedef realm_collection_move_t = realm_collection_move;

enum realm_collection_type {
  RLM_COLLECTION_TYPE_NONE(0),
  RLM_COLLECTION_TYPE_LIST(1),
  RLM_COLLECTION_TYPE_SET(2),
  RLM_COLLECTION_TYPE_DICTIONARY(4);

  final int value;
  const realm_collection_type(this.value);

  static realm_collection_type fromValue(int value) => switch (value) {
        0 => RLM_COLLECTION_TYPE_NONE,
        1 => RLM_COLLECTION_TYPE_LIST,
        2 => RLM_COLLECTION_TYPE_SET,
        4 => RLM_COLLECTION_TYPE_DICTIONARY,
        _ => throw ArgumentError(
            "Unknown value for realm_collection_type: $value"),
      };
}

/// Schema types
enum realm_column_attr {
  /// Values matching `realm::ColumnAttr`.
  RLM_COLUMN_ATTR_NONE(0),
  RLM_COLUMN_ATTR_INDEXED(1),
  RLM_COLUMN_ATTR_UNIQUE(2),
  RLM_COLUMN_ATTR_RESERVED(4),
  RLM_COLUMN_ATTR_STRONG_LINKS(8),
  RLM_COLUMN_ATTR_NULLABLE(16),
  RLM_COLUMN_ATTR_LIST(32),
  RLM_COLUMN_ATTR_DICTIONARY(64),
  RLM_COLUMN_ATTR_COLLECTION(96);

  final int value;
  const realm_column_attr(this.value);

  static realm_column_attr fromValue(int value) => switch (value) {
        0 => RLM_COLUMN_ATTR_NONE,
        1 => RLM_COLUMN_ATTR_INDEXED,
        2 => RLM_COLUMN_ATTR_UNIQUE,
        4 => RLM_COLUMN_ATTR_RESERVED,
        8 => RLM_COLUMN_ATTR_STRONG_LINKS,
        16 => RLM_COLUMN_ATTR_NULLABLE,
        32 => RLM_COLUMN_ATTR_LIST,
        64 => RLM_COLUMN_ATTR_DICTIONARY,
        96 => RLM_COLUMN_ATTR_COLLECTION,
        _ => throw ArgumentError("Unknown value for realm_column_attr: $value"),
      };
}

final class realm_config extends ffi.Opaque {}

/// Config types
typedef realm_config_t = realm_config;

final class realm_dart_userdata_async extends ffi.Opaque {}

typedef realm_dart_userdata_async_t = ffi.Pointer<realm_dart_userdata_async>;
typedef realm_data_initialization_func_t
    = ffi.Pointer<ffi.NativeFunction<realm_data_initialization_func_tFunction>>;
typedef realm_data_initialization_func_tFunction = ffi.Bool Function(
    ffi.Pointer<ffi.Void> userdata, ffi.Pointer<realm_t> realm);
typedef Dartrealm_data_initialization_func_tFunction = bool Function(
    ffi.Pointer<ffi.Void> userdata, ffi.Pointer<realm_t> realm);

final class realm_decimal128 extends ffi.Struct {
  @ffi.Array.multi([2])
  external ffi.Array<ffi.Uint64> w;
}

typedef realm_decimal128_t = realm_decimal128;

final class realm_dictionary extends ffi.Opaque {}

final class realm_dictionary_changes extends ffi.Opaque {}

typedef realm_dictionary_changes_t = realm_dictionary_changes;
typedef realm_dictionary_t = realm_dictionary;

enum realm_errno {
  RLM_ERR_NONE(0),
  RLM_ERR_RUNTIME(1000),
  RLM_ERR_RANGE_ERROR(1001),
  RLM_ERR_BROKEN_INVARIANT(1002),
  RLM_ERR_OUT_OF_MEMORY(1003),
  RLM_ERR_OUT_OF_DISK_SPACE(1004),
  RLM_ERR_ADDRESS_SPACE_EXHAUSTED(1005),
  RLM_ERR_MAXIMUM_FILE_SIZE_EXCEEDED(1006),
  RLM_ERR_INCOMPATIBLE_SESSION(1007),
  RLM_ERR_INCOMPATIBLE_LOCK_FILE(1008),
  RLM_ERR_INVALID_QUERY(1009),
  RLM_ERR_BAD_VERSION(1010),
  RLM_ERR_UNSUPPORTED_FILE_FORMAT_VERSION(1011),
  RLM_ERR_MULTIPLE_SYNC_AGENTS(1012),
  RLM_ERR_OBJECT_ALREADY_EXISTS(1013),
  RLM_ERR_NOT_CLONABLE(1014),
  RLM_ERR_BAD_CHANGESET(1015),
  RLM_ERR_SUBSCRIPTION_FAILED(1016),
  RLM_ERR_FILE_OPERATION_FAILED(1017),
  RLM_ERR_FILE_PERMISSION_DENIED(1018),
  RLM_ERR_FILE_NOT_FOUND(1019),
  RLM_ERR_FILE_ALREADY_EXISTS(1020),
  RLM_ERR_INVALID_DATABASE(1021),
  RLM_ERR_DECRYPTION_FAILED(1022),
  RLM_ERR_INCOMPATIBLE_HISTORIES(1023),
  RLM_ERR_FILE_FORMAT_UPGRADE_REQUIRED(1024),
  RLM_ERR_SCHEMA_VERSION_MISMATCH(1025),
  RLM_ERR_NO_SUBSCRIPTION_FOR_WRITE(1026),
  RLM_ERR_OPERATION_ABORTED(1027),
  RLM_ERR_AUTO_CLIENT_RESET_FAILED(1028),
  RLM_ERR_BAD_SYNC_PARTITION_VALUE(1029),
  RLM_ERR_CONNECTION_CLOSED(1030),
  RLM_ERR_INVALID_SUBSCRIPTION_QUERY(1031),
  RLM_ERR_SYNC_CLIENT_RESET_REQUIRED(1032),
  RLM_ERR_SYNC_COMPENSATING_WRITE(1033),
  RLM_ERR_SYNC_CONNECT_FAILED(1034),
  RLM_ERR_SYNC_CONNECT_TIMEOUT(1035),
  RLM_ERR_SYNC_INVALID_SCHEMA_CHANGE(1036),
  RLM_ERR_SYNC_PERMISSION_DENIED(1037),
  RLM_ERR_SYNC_PROTOCOL_INVARIANT_FAILED(1038),
  RLM_ERR_SYNC_PROTOCOL_NEGOTIATION_FAILED(1039),
  RLM_ERR_SYNC_SERVER_PERMISSIONS_CHANGED(1040),
  RLM_ERR_SYNC_USER_MISMATCH(1041),
  RLM_ERR_TLS_HANDSHAKE_FAILED(1042),
  RLM_ERR_WRONG_SYNC_TYPE(1043),
  RLM_ERR_SYNC_WRITE_NOT_ALLOWED(1044),
  RLM_ERR_SYNC_LOCAL_CLOCK_BEFORE_EPOCH(1045),
  RLM_ERR_SYNC_SCHEMA_MIGRATION_ERROR(1046),
  RLM_ERR_SYSTEM_ERROR(1999),
  RLM_ERR_LOGIC(2000),
  RLM_ERR_NOT_SUPPORTED(2001),
  RLM_ERR_BROKEN_PROMISE(2002),
  RLM_ERR_CROSS_TABLE_LINK_TARGET(2003),
  RLM_ERR_KEY_ALREADY_USED(2004),
  RLM_ERR_WRONG_TRANSACTION_STATE(2005),
  RLM_ERR_WRONG_THREAD(2006),
  RLM_ERR_ILLEGAL_OPERATION(2007),
  RLM_ERR_SERIALIZATION_ERROR(2008),
  RLM_ERR_STALE_ACCESSOR(2009),
  RLM_ERR_INVALIDATED_OBJECT(2010),
  RLM_ERR_READ_ONLY_DB(2011),
  RLM_ERR_DELETE_OPENED_REALM(2012),
  RLM_ERR_MISMATCHED_CONFIG(2013),
  RLM_ERR_CLOSED_REALM(2014),
  RLM_ERR_INVALID_TABLE_REF(2015),
  RLM_ERR_SCHEMA_VALIDATION_FAILED(2016),
  RLM_ERR_SCHEMA_MISMATCH(2017),
  RLM_ERR_INVALID_SCHEMA_VERSION(2018),
  RLM_ERR_INVALID_SCHEMA_CHANGE(2019),
  RLM_ERR_MIGRATION_FAILED(2020),
  RLM_ERR_TOP_LEVEL_OBJECT(2021),
  RLM_ERR_INVALID_ARGUMENT(3000),
  RLM_ERR_PROPERTY_TYPE_MISMATCH(3001),
  RLM_ERR_PROPERTY_NOT_NULLABLE(3002),
  RLM_ERR_READ_ONLY_PROPERTY(3003),
  RLM_ERR_MISSING_PROPERTY_VALUE(3004),
  RLM_ERR_MISSING_PRIMARY_KEY(3005),
  RLM_ERR_UNEXPECTED_PRIMARY_KEY(3006),
  RLM_ERR_MODIFY_PRIMARY_KEY(3007),
  RLM_ERR_INVALID_QUERY_STRING(3008),
  RLM_ERR_INVALID_PROPERTY(3009),
  RLM_ERR_INVALID_NAME(3010),
  RLM_ERR_INVALID_DICTIONARY_KEY(3011),
  RLM_ERR_INVALID_DICTIONARY_VALUE(3012),
  RLM_ERR_INVALID_SORT_DESCRIPTOR(3013),
  RLM_ERR_INVALID_ENCRYPTION_KEY(3014),
  RLM_ERR_INVALID_QUERY_ARG(3015),
  RLM_ERR_NO_SUCH_OBJECT(3016),
  RLM_ERR_INDEX_OUT_OF_BOUNDS(3017),
  RLM_ERR_LIMIT_EXCEEDED(3018),
  RLM_ERR_OBJECT_TYPE_MISMATCH(3019),
  RLM_ERR_NO_SUCH_TABLE(3020),
  RLM_ERR_TABLE_NAME_IN_USE(3021),
  RLM_ERR_ILLEGAL_COMBINATION(3022),
  RLM_ERR_BAD_SERVER_URL(3023),
  RLM_ERR_CUSTOM_ERROR(4000),
  RLM_ERR_CLIENT_USER_NOT_FOUND(4100),
  RLM_ERR_CLIENT_USER_NOT_LOGGED_IN(4101),
  RLM_ERR_CLIENT_REDIRECT_ERROR(4103),
  RLM_ERR_CLIENT_TOO_MANY_REDIRECTS(4104),
  RLM_ERR_CLIENT_USER_ALREADY_NAMED(4105),
  RLM_ERR_BAD_TOKEN(4200),
  RLM_ERR_MALFORMED_JSON(4201),
  RLM_ERR_MISSING_JSON_KEY(4202),
  RLM_ERR_BAD_BSON_PARSE(4203),
  RLM_ERR_MISSING_AUTH_REQ(4300),
  RLM_ERR_INVALID_SESSION(4301),
  RLM_ERR_USER_APP_DOMAIN_MISMATCH(4302),
  RLM_ERR_DOMAIN_NOT_ALLOWED(4303),
  RLM_ERR_READ_SIZE_LIMIT_EXCEEDED(4304),
  RLM_ERR_INVALID_PARAMETER(4305),
  RLM_ERR_MISSING_PARAMETER(4306),
  RLM_ERR_TWILIO_ERROR(4307),
  RLM_ERR_GCM_ERROR(4308),
  RLM_ERR_HTTP_ERROR(4309),
  RLM_ERR_AWS_ERROR(4310),
  RLM_ERR_MONGODB_ERROR(4311),
  RLM_ERR_ARGUMENTS_NOT_ALLOWED(4312),
  RLM_ERR_FUNCTION_EXECUTION_ERROR(4313),
  RLM_ERR_NO_MATCHING_RULE_FOUND(4314),
  RLM_ERR_INTERNAL_SERVER_ERROR(4315),
  RLM_ERR_AUTH_PROVIDER_NOT_FOUND(4316),
  RLM_ERR_AUTH_PROVIDER_ALREADY_EXISTS(4317),
  RLM_ERR_SERVICE_NOT_FOUND(4318),
  RLM_ERR_SERVICE_TYPE_NOT_FOUND(4319),
  RLM_ERR_SERVICE_ALREADY_EXISTS(4320),
  RLM_ERR_SERVICE_COMMAND_NOT_FOUND(4321),
  RLM_ERR_VALUE_NOT_FOUND(4322),
  RLM_ERR_VALUE_ALREADY_EXISTS(4323),
  RLM_ERR_VALUE_DUPLICATE_NAME(4324),
  RLM_ERR_FUNCTION_NOT_FOUND(4325),
  RLM_ERR_FUNCTION_ALREADY_EXISTS(4326),
  RLM_ERR_FUNCTION_DUPLICATE_NAME(4327),
  RLM_ERR_FUNCTION_SYNTAX_ERROR(4328),
  RLM_ERR_FUNCTION_INVALID(4329),
  RLM_ERR_INCOMING_WEBHOOK_NOT_FOUND(4330),
  RLM_ERR_INCOMING_WEBHOOK_ALREADY_EXISTS(4331),
  RLM_ERR_INCOMING_WEBHOOK_DUPLICATE_NAME(4332),
  RLM_ERR_RULE_NOT_FOUND(4333),
  RLM_ERR_API_KEY_NOT_FOUND(4334),
  RLM_ERR_RULE_ALREADY_EXISTS(4335),
  RLM_ERR_RULE_DUPLICATE_NAME(4336),
  RLM_ERR_AUTH_PROVIDER_DUPLICATE_NAME(4337),
  RLM_ERR_RESTRICTED_HOST(4338),
  RLM_ERR_API_KEY_ALREADY_EXISTS(4339),
  RLM_ERR_INCOMING_WEBHOOK_AUTH_FAILED(4340),
  RLM_ERR_EXECUTION_TIME_LIMIT_EXCEEDED(4341),
  RLM_ERR_NOT_CALLABLE(4342),
  RLM_ERR_USER_ALREADY_CONFIRMED(4343),
  RLM_ERR_USER_NOT_FOUND(4344),
  RLM_ERR_USER_DISABLED(4345),
  RLM_ERR_AUTH_ERROR(4346),
  RLM_ERR_BAD_REQUEST(4347),
  RLM_ERR_ACCOUNT_NAME_IN_USE(4348),
  RLM_ERR_INVALID_PASSWORD(4349),
  RLM_ERR_SCHEMA_VALIDATION_FAILED_WRITE(4350),
  RLM_ERR_APP_UNKNOWN(4351),
  RLM_ERR_MAINTENANCE_IN_PROGRESS(4352),
  RLM_ERR_USERPASS_TOKEN_INVALID(4353),
  RLM_ERR_INVALID_SERVER_RESPONSE(4354),
  RLM_ERR_APP_SERVER_ERROR(4355),

  /// < A user-provided callback failed.
  RLM_ERR_CALLBACK(1000000),

  /// Should not be used in code
  RLM_ERR_UNKNOWN(2000000);

  final int value;
  const realm_errno(this.value);

  static realm_errno fromValue(int value) => switch (value) {
        0 => RLM_ERR_NONE,
        1000 => RLM_ERR_RUNTIME,
        1001 => RLM_ERR_RANGE_ERROR,
        1002 => RLM_ERR_BROKEN_INVARIANT,
        1003 => RLM_ERR_OUT_OF_MEMORY,
        1004 => RLM_ERR_OUT_OF_DISK_SPACE,
        1005 => RLM_ERR_ADDRESS_SPACE_EXHAUSTED,
        1006 => RLM_ERR_MAXIMUM_FILE_SIZE_EXCEEDED,
        1007 => RLM_ERR_INCOMPATIBLE_SESSION,
        1008 => RLM_ERR_INCOMPATIBLE_LOCK_FILE,
        1009 => RLM_ERR_INVALID_QUERY,
        1010 => RLM_ERR_BAD_VERSION,
        1011 => RLM_ERR_UNSUPPORTED_FILE_FORMAT_VERSION,
        1012 => RLM_ERR_MULTIPLE_SYNC_AGENTS,
        1013 => RLM_ERR_OBJECT_ALREADY_EXISTS,
        1014 => RLM_ERR_NOT_CLONABLE,
        1015 => RLM_ERR_BAD_CHANGESET,
        1016 => RLM_ERR_SUBSCRIPTION_FAILED,
        1017 => RLM_ERR_FILE_OPERATION_FAILED,
        1018 => RLM_ERR_FILE_PERMISSION_DENIED,
        1019 => RLM_ERR_FILE_NOT_FOUND,
        1020 => RLM_ERR_FILE_ALREADY_EXISTS,
        1021 => RLM_ERR_INVALID_DATABASE,
        1022 => RLM_ERR_DECRYPTION_FAILED,
        1023 => RLM_ERR_INCOMPATIBLE_HISTORIES,
        1024 => RLM_ERR_FILE_FORMAT_UPGRADE_REQUIRED,
        1025 => RLM_ERR_SCHEMA_VERSION_MISMATCH,
        1026 => RLM_ERR_NO_SUBSCRIPTION_FOR_WRITE,
        1027 => RLM_ERR_OPERATION_ABORTED,
        1028 => RLM_ERR_AUTO_CLIENT_RESET_FAILED,
        1029 => RLM_ERR_BAD_SYNC_PARTITION_VALUE,
        1030 => RLM_ERR_CONNECTION_CLOSED,
        1031 => RLM_ERR_INVALID_SUBSCRIPTION_QUERY,
        1032 => RLM_ERR_SYNC_CLIENT_RESET_REQUIRED,
        1033 => RLM_ERR_SYNC_COMPENSATING_WRITE,
        1034 => RLM_ERR_SYNC_CONNECT_FAILED,
        1035 => RLM_ERR_SYNC_CONNECT_TIMEOUT,
        1036 => RLM_ERR_SYNC_INVALID_SCHEMA_CHANGE,
        1037 => RLM_ERR_SYNC_PERMISSION_DENIED,
        1038 => RLM_ERR_SYNC_PROTOCOL_INVARIANT_FAILED,
        1039 => RLM_ERR_SYNC_PROTOCOL_NEGOTIATION_FAILED,
        1040 => RLM_ERR_SYNC_SERVER_PERMISSIONS_CHANGED,
        1041 => RLM_ERR_SYNC_USER_MISMATCH,
        1042 => RLM_ERR_TLS_HANDSHAKE_FAILED,
        1043 => RLM_ERR_WRONG_SYNC_TYPE,
        1044 => RLM_ERR_SYNC_WRITE_NOT_ALLOWED,
        1045 => RLM_ERR_SYNC_LOCAL_CLOCK_BEFORE_EPOCH,
        1046 => RLM_ERR_SYNC_SCHEMA_MIGRATION_ERROR,
        1999 => RLM_ERR_SYSTEM_ERROR,
        2000 => RLM_ERR_LOGIC,
        2001 => RLM_ERR_NOT_SUPPORTED,
        2002 => RLM_ERR_BROKEN_PROMISE,
        2003 => RLM_ERR_CROSS_TABLE_LINK_TARGET,
        2004 => RLM_ERR_KEY_ALREADY_USED,
        2005 => RLM_ERR_WRONG_TRANSACTION_STATE,
        2006 => RLM_ERR_WRONG_THREAD,
        2007 => RLM_ERR_ILLEGAL_OPERATION,
        2008 => RLM_ERR_SERIALIZATION_ERROR,
        2009 => RLM_ERR_STALE_ACCESSOR,
        2010 => RLM_ERR_INVALIDATED_OBJECT,
        2011 => RLM_ERR_READ_ONLY_DB,
        2012 => RLM_ERR_DELETE_OPENED_REALM,
        2013 => RLM_ERR_MISMATCHED_CONFIG,
        2014 => RLM_ERR_CLOSED_REALM,
        2015 => RLM_ERR_INVALID_TABLE_REF,
        2016 => RLM_ERR_SCHEMA_VALIDATION_FAILED,
        2017 => RLM_ERR_SCHEMA_MISMATCH,
        2018 => RLM_ERR_INVALID_SCHEMA_VERSION,
        2019 => RLM_ERR_INVALID_SCHEMA_CHANGE,
        2020 => RLM_ERR_MIGRATION_FAILED,
        2021 => RLM_ERR_TOP_LEVEL_OBJECT,
        3000 => RLM_ERR_INVALID_ARGUMENT,
        3001 => RLM_ERR_PROPERTY_TYPE_MISMATCH,
        3002 => RLM_ERR_PROPERTY_NOT_NULLABLE,
        3003 => RLM_ERR_READ_ONLY_PROPERTY,
        3004 => RLM_ERR_MISSING_PROPERTY_VALUE,
        3005 => RLM_ERR_MISSING_PRIMARY_KEY,
        3006 => RLM_ERR_UNEXPECTED_PRIMARY_KEY,
        3007 => RLM_ERR_MODIFY_PRIMARY_KEY,
        3008 => RLM_ERR_INVALID_QUERY_STRING,
        3009 => RLM_ERR_INVALID_PROPERTY,
        3010 => RLM_ERR_INVALID_NAME,
        3011 => RLM_ERR_INVALID_DICTIONARY_KEY,
        3012 => RLM_ERR_INVALID_DICTIONARY_VALUE,
        3013 => RLM_ERR_INVALID_SORT_DESCRIPTOR,
        3014 => RLM_ERR_INVALID_ENCRYPTION_KEY,
        3015 => RLM_ERR_INVALID_QUERY_ARG,
        3016 => RLM_ERR_NO_SUCH_OBJECT,
        3017 => RLM_ERR_INDEX_OUT_OF_BOUNDS,
        3018 => RLM_ERR_LIMIT_EXCEEDED,
        3019 => RLM_ERR_OBJECT_TYPE_MISMATCH,
        3020 => RLM_ERR_NO_SUCH_TABLE,
        3021 => RLM_ERR_TABLE_NAME_IN_USE,
        3022 => RLM_ERR_ILLEGAL_COMBINATION,
        3023 => RLM_ERR_BAD_SERVER_URL,
        4000 => RLM_ERR_CUSTOM_ERROR,
        4100 => RLM_ERR_CLIENT_USER_NOT_FOUND,
        4101 => RLM_ERR_CLIENT_USER_NOT_LOGGED_IN,
        4103 => RLM_ERR_CLIENT_REDIRECT_ERROR,
        4104 => RLM_ERR_CLIENT_TOO_MANY_REDIRECTS,
        4105 => RLM_ERR_CLIENT_USER_ALREADY_NAMED,
        4200 => RLM_ERR_BAD_TOKEN,
        4201 => RLM_ERR_MALFORMED_JSON,
        4202 => RLM_ERR_MISSING_JSON_KEY,
        4203 => RLM_ERR_BAD_BSON_PARSE,
        4300 => RLM_ERR_MISSING_AUTH_REQ,
        4301 => RLM_ERR_INVALID_SESSION,
        4302 => RLM_ERR_USER_APP_DOMAIN_MISMATCH,
        4303 => RLM_ERR_DOMAIN_NOT_ALLOWED,
        4304 => RLM_ERR_READ_SIZE_LIMIT_EXCEEDED,
        4305 => RLM_ERR_INVALID_PARAMETER,
        4306 => RLM_ERR_MISSING_PARAMETER,
        4307 => RLM_ERR_TWILIO_ERROR,
        4308 => RLM_ERR_GCM_ERROR,
        4309 => RLM_ERR_HTTP_ERROR,
        4310 => RLM_ERR_AWS_ERROR,
        4311 => RLM_ERR_MONGODB_ERROR,
        4312 => RLM_ERR_ARGUMENTS_NOT_ALLOWED,
        4313 => RLM_ERR_FUNCTION_EXECUTION_ERROR,
        4314 => RLM_ERR_NO_MATCHING_RULE_FOUND,
        4315 => RLM_ERR_INTERNAL_SERVER_ERROR,
        4316 => RLM_ERR_AUTH_PROVIDER_NOT_FOUND,
        4317 => RLM_ERR_AUTH_PROVIDER_ALREADY_EXISTS,
        4318 => RLM_ERR_SERVICE_NOT_FOUND,
        4319 => RLM_ERR_SERVICE_TYPE_NOT_FOUND,
        4320 => RLM_ERR_SERVICE_ALREADY_EXISTS,
        4321 => RLM_ERR_SERVICE_COMMAND_NOT_FOUND,
        4322 => RLM_ERR_VALUE_NOT_FOUND,
        4323 => RLM_ERR_VALUE_ALREADY_EXISTS,
        4324 => RLM_ERR_VALUE_DUPLICATE_NAME,
        4325 => RLM_ERR_FUNCTION_NOT_FOUND,
        4326 => RLM_ERR_FUNCTION_ALREADY_EXISTS,
        4327 => RLM_ERR_FUNCTION_DUPLICATE_NAME,
        4328 => RLM_ERR_FUNCTION_SYNTAX_ERROR,
        4329 => RLM_ERR_FUNCTION_INVALID,
        4330 => RLM_ERR_INCOMING_WEBHOOK_NOT_FOUND,
        4331 => RLM_ERR_INCOMING_WEBHOOK_ALREADY_EXISTS,
        4332 => RLM_ERR_INCOMING_WEBHOOK_DUPLICATE_NAME,
        4333 => RLM_ERR_RULE_NOT_FOUND,
        4334 => RLM_ERR_API_KEY_NOT_FOUND,
        4335 => RLM_ERR_RULE_ALREADY_EXISTS,
        4336 => RLM_ERR_RULE_DUPLICATE_NAME,
        4337 => RLM_ERR_AUTH_PROVIDER_DUPLICATE_NAME,
        4338 => RLM_ERR_RESTRICTED_HOST,
        4339 => RLM_ERR_API_KEY_ALREADY_EXISTS,
        4340 => RLM_ERR_INCOMING_WEBHOOK_AUTH_FAILED,
        4341 => RLM_ERR_EXECUTION_TIME_LIMIT_EXCEEDED,
        4342 => RLM_ERR_NOT_CALLABLE,
        4343 => RLM_ERR_USER_ALREADY_CONFIRMED,
        4344 => RLM_ERR_USER_NOT_FOUND,
        4345 => RLM_ERR_USER_DISABLED,
        4346 => RLM_ERR_AUTH_ERROR,
        4347 => RLM_ERR_BAD_REQUEST,
        4348 => RLM_ERR_ACCOUNT_NAME_IN_USE,
        4349 => RLM_ERR_INVALID_PASSWORD,
        4350 => RLM_ERR_SCHEMA_VALIDATION_FAILED_WRITE,
        4351 => RLM_ERR_APP_UNKNOWN,
        4352 => RLM_ERR_MAINTENANCE_IN_PROGRESS,
        4353 => RLM_ERR_USERPASS_TOKEN_INVALID,
        4354 => RLM_ERR_INVALID_SERVER_RESPONSE,
        4355 => RLM_ERR_APP_SERVER_ERROR,
        1000000 => RLM_ERR_CALLBACK,
        2000000 => RLM_ERR_UNKNOWN,
        _ => throw ArgumentError("Unknown value for realm_errno: $value"),
      };
}

final class realm_error extends ffi.Struct {
  @ffi.UnsignedInt()
  external int error;

  @realm_error_categories()
  external int categories;

  external ffi.Pointer<ffi.Char> message;

  /// When error is RLM_ERR_CALLBACK this is an opaque pointer to an SDK-owned error object
  /// thrown by user code inside a callback with realm_register_user_code_callback_error(), otherwise null.
  external ffi.Pointer<ffi.Void> user_code_error;

  external ffi.Pointer<ffi.Char> path;
}

typedef realm_error_categories = ffi.UnsignedInt;
typedef Dartrealm_error_categories = int;
typedef realm_error_t = realm_error;
typedef realm_free_userdata_func_t
    = ffi.Pointer<ffi.NativeFunction<realm_free_userdata_func_tFunction>>;
typedef realm_free_userdata_func_tFunction = ffi.Void Function(
    ffi.Pointer<ffi.Void> userdata);
typedef Dartrealm_free_userdata_func_tFunction = void Function(
    ffi.Pointer<ffi.Void> userdata);

final class realm_index_range extends ffi.Struct {
  @ffi.Size()
  external int from;

  @ffi.Size()
  external int to;
}

typedef realm_index_range_t = realm_index_range;

final class realm_key_path_array extends ffi.Opaque {}

typedef realm_key_path_array_t = realm_key_path_array;

final class realm_link extends ffi.Struct {
  @realm_class_key_t()
  external int target_table;

  @realm_object_key_t()
  external int target;
}

typedef realm_link_t = realm_link;

final class realm_list extends ffi.Opaque {}

typedef realm_list_t = realm_list;
typedef realm_log_func_t
    = ffi.Pointer<ffi.NativeFunction<realm_log_func_tFunction>>;
typedef realm_log_func_tFunction = ffi.Void Function(
    ffi.Pointer<ffi.Void> userdata,
    ffi.Pointer<ffi.Char> category,
    ffi.UnsignedInt level,
    ffi.Pointer<ffi.Char> message);
typedef Dartrealm_log_func_tFunction = void Function(
    ffi.Pointer<ffi.Void> userdata,
    ffi.Pointer<ffi.Char> category,
    realm_log_level level,
    ffi.Pointer<ffi.Char> message);

/// Logging */
/// // equivalent to realm::util::Logger::Level in util/logger.hpp and must be kept in sync.
enum realm_log_level {
  RLM_LOG_LEVEL_ALL(0),
  RLM_LOG_LEVEL_TRACE(1),
  RLM_LOG_LEVEL_DEBUG(2),
  RLM_LOG_LEVEL_DETAIL(3),
  RLM_LOG_LEVEL_INFO(4),
  RLM_LOG_LEVEL_WARNING(5),
  RLM_LOG_LEVEL_ERROR(6),
  RLM_LOG_LEVEL_FATAL(7),
  RLM_LOG_LEVEL_OFF(8);

  final int value;
  const realm_log_level(this.value);

  static realm_log_level fromValue(int value) => switch (value) {
        0 => RLM_LOG_LEVEL_ALL,
        1 => RLM_LOG_LEVEL_TRACE,
        2 => RLM_LOG_LEVEL_DEBUG,
        3 => RLM_LOG_LEVEL_DETAIL,
        4 => RLM_LOG_LEVEL_INFO,
        5 => RLM_LOG_LEVEL_WARNING,
        6 => RLM_LOG_LEVEL_ERROR,
        7 => RLM_LOG_LEVEL_FATAL,
        8 => RLM_LOG_LEVEL_OFF,
        _ => throw ArgumentError("Unknown value for realm_log_level: $value"),
      };
}

typedef realm_migration_func_t
    = ffi.Pointer<ffi.NativeFunction<realm_migration_func_tFunction>>;
typedef realm_migration_func_tFunction = ffi.Bool Function(
    ffi.Pointer<ffi.Void> userdata,
    ffi.Pointer<realm_t> old_realm,
    ffi.Pointer<realm_t> new_realm,
    ffi.Pointer<realm_schema_t> schema);
typedef Dartrealm_migration_func_tFunction = bool Function(
    ffi.Pointer<ffi.Void> userdata,
    ffi.Pointer<realm_t> old_realm,
    ffi.Pointer<realm_t> new_realm,
    ffi.Pointer<realm_schema_t> schema);

final class realm_notification_token extends ffi.Opaque {}

/// Notification types
typedef realm_notification_token_t = realm_notification_token;

final class realm_object extends ffi.Opaque {}

final class realm_object_changes extends ffi.Opaque {}

typedef realm_object_changes_t = realm_object_changes;

final class realm_object_id extends ffi.Struct {
  @ffi.Array.multi([12])
  external ffi.Array<ffi.Uint8> bytes;
}

typedef realm_object_id_t = realm_object_id;
typedef realm_object_key_t = ffi.Int64;
typedef Dartrealm_object_key_t = int;

/// Accessor types
typedef realm_object_t = realm_object;
typedef realm_on_collection_change_func_t = ffi
    .Pointer<ffi.NativeFunction<realm_on_collection_change_func_tFunction>>;
typedef realm_on_collection_change_func_tFunction = ffi.Void Function(
    ffi.Pointer<ffi.Void>, ffi.Pointer<realm_collection_changes_t>);
typedef Dartrealm_on_collection_change_func_tFunction = void Function(
    ffi.Pointer<ffi.Void>, ffi.Pointer<realm_collection_changes_t>);
typedef realm_on_dictionary_change_func_t = ffi
    .Pointer<ffi.NativeFunction<realm_on_dictionary_change_func_tFunction>>;
typedef realm_on_dictionary_change_func_tFunction = ffi.Void Function(
    ffi.Pointer<ffi.Void>, ffi.Pointer<realm_dictionary_changes_t>);
typedef Dartrealm_on_dictionary_change_func_tFunction = void Function(
    ffi.Pointer<ffi.Void>, ffi.Pointer<realm_dictionary_changes_t>);
typedef realm_on_object_change_func_t
    = ffi.Pointer<ffi.NativeFunction<realm_on_object_change_func_tFunction>>;
typedef realm_on_object_change_func_tFunction = ffi.Void Function(
    ffi.Pointer<ffi.Void>, ffi.Pointer<realm_object_changes_t>);
typedef Dartrealm_on_object_change_func_tFunction = void Function(
    ffi.Pointer<ffi.Void>, ffi.Pointer<realm_object_changes_t>);
typedef realm_on_realm_change_func_t
    = ffi.Pointer<ffi.NativeFunction<realm_on_realm_change_func_tFunction>>;
typedef realm_on_realm_change_func_tFunction = ffi.Void Function(
    ffi.Pointer<ffi.Void> userdata);
typedef Dartrealm_on_realm_change_func_tFunction = void Function(
    ffi.Pointer<ffi.Void> userdata);
typedef realm_on_realm_refresh_func_t
    = ffi.Pointer<ffi.NativeFunction<realm_on_realm_refresh_func_tFunction>>;
typedef realm_on_realm_refresh_func_tFunction = ffi.Void Function(
    ffi.Pointer<ffi.Void> userdata);
typedef Dartrealm_on_realm_refresh_func_tFunction = void Function(
    ffi.Pointer<ffi.Void> userdata);

/// Callback for realm schema changed notifications.
///
/// @param new_schema The new schema. This object is released after the callback returns.
/// Preserve it with realm_clone() if you wish to keep it around for longer.
typedef realm_on_schema_change_func_t
    = ffi.Pointer<ffi.NativeFunction<realm_on_schema_change_func_tFunction>>;
typedef realm_on_schema_change_func_tFunction = ffi.Void Function(
    ffi.Pointer<ffi.Void> userdata, ffi.Pointer<realm_schema_t> new_schema);
typedef Dartrealm_on_schema_change_func_tFunction = void Function(
    ffi.Pointer<ffi.Void> userdata, ffi.Pointer<realm_schema_t> new_schema);

enum realm_property_flags {
  RLM_PROPERTY_NORMAL(0),
  RLM_PROPERTY_NULLABLE(1),
  RLM_PROPERTY_PRIMARY_KEY(2),
  RLM_PROPERTY_INDEXED(4),
  RLM_PROPERTY_FULLTEXT_INDEXED(8);

  final int value;
  const realm_property_flags(this.value);

  static realm_property_flags fromValue(int value) => switch (value) {
        0 => RLM_PROPERTY_NORMAL,
        1 => RLM_PROPERTY_NULLABLE,
        2 => RLM_PROPERTY_PRIMARY_KEY,
        4 => RLM_PROPERTY_INDEXED,
        8 => RLM_PROPERTY_FULLTEXT_INDEXED,
        _ =>
          throw ArgumentError("Unknown value for realm_property_flags: $value"),
      };
}

final class realm_property_info extends ffi.Struct {
  external ffi.Pointer<ffi.Char> name;

  external ffi.Pointer<ffi.Char> public_name;

  @ffi.UnsignedInt()
  external int type;

  @ffi.UnsignedInt()
  external int collection_type;

  external ffi.Pointer<ffi.Char> link_target;

  external ffi.Pointer<ffi.Char> link_origin_property_name;

  @realm_property_key_t()
  external int key;

  @ffi.Int()
  external int flags;
}

typedef realm_property_info_t = realm_property_info;
typedef realm_property_key_t = ffi.Int64;
typedef Dartrealm_property_key_t = int;

enum realm_property_type {
  /// Values matching `realm::ColumnType`.
  RLM_PROPERTY_TYPE_INT(0),
  RLM_PROPERTY_TYPE_BOOL(1),
  RLM_PROPERTY_TYPE_STRING(2),
  RLM_PROPERTY_TYPE_BINARY(4),
  RLM_PROPERTY_TYPE_MIXED(6),
  RLM_PROPERTY_TYPE_TIMESTAMP(8),
  RLM_PROPERTY_TYPE_FLOAT(9),
  RLM_PROPERTY_TYPE_DOUBLE(10),
  RLM_PROPERTY_TYPE_DECIMAL128(11),
  RLM_PROPERTY_TYPE_OBJECT(12),
  RLM_PROPERTY_TYPE_LINKING_OBJECTS(14),
  RLM_PROPERTY_TYPE_OBJECT_ID(15),
  RLM_PROPERTY_TYPE_UUID(17);

  final int value;
  const realm_property_type(this.value);

  static realm_property_type fromValue(int value) => switch (value) {
        0 => RLM_PROPERTY_TYPE_INT,
        1 => RLM_PROPERTY_TYPE_BOOL,
        2 => RLM_PROPERTY_TYPE_STRING,
        4 => RLM_PROPERTY_TYPE_BINARY,
        6 => RLM_PROPERTY_TYPE_MIXED,
        8 => RLM_PROPERTY_TYPE_TIMESTAMP,
        9 => RLM_PROPERTY_TYPE_FLOAT,
        10 => RLM_PROPERTY_TYPE_DOUBLE,
        11 => RLM_PROPERTY_TYPE_DECIMAL128,
        12 => RLM_PROPERTY_TYPE_OBJECT,
        14 => RLM_PROPERTY_TYPE_LINKING_OBJECTS,
        15 => RLM_PROPERTY_TYPE_OBJECT_ID,
        17 => RLM_PROPERTY_TYPE_UUID,
        _ =>
          throw ArgumentError("Unknown value for realm_property_type: $value"),
      };
}

final class realm_query extends ffi.Opaque {}

final class realm_query_arg extends ffi.Struct {
  @ffi.Size()
  external int nb_args;

  @ffi.Bool()
  external bool is_list;

  external ffi.Pointer<realm_value_t> arg;
}

typedef realm_query_arg_t = realm_query_arg;

/// Query types
typedef realm_query_t = realm_query;

final class realm_refresh_callback_token extends ffi.Opaque {}

typedef realm_refresh_callback_token_t = realm_refresh_callback_token;

final class realm_results extends ffi.Opaque {}

typedef realm_results_t = realm_results;

final class realm_scheduler extends ffi.Opaque {}

typedef realm_scheduler_can_deliver_notifications_func_t = ffi.Pointer<
    ffi
    .NativeFunction<realm_scheduler_can_deliver_notifications_func_tFunction>>;
typedef realm_scheduler_can_deliver_notifications_func_tFunction = ffi.Bool
    Function(ffi.Pointer<ffi.Void> userdata);
typedef Dartrealm_scheduler_can_deliver_notifications_func_tFunction = bool
    Function(ffi.Pointer<ffi.Void> userdata);
typedef realm_scheduler_is_on_thread_func_t = ffi
    .Pointer<ffi.NativeFunction<realm_scheduler_is_on_thread_func_tFunction>>;
typedef realm_scheduler_is_on_thread_func_tFunction = ffi.Bool Function(
    ffi.Pointer<ffi.Void> userdata);
typedef Dartrealm_scheduler_is_on_thread_func_tFunction = bool Function(
    ffi.Pointer<ffi.Void> userdata);
typedef realm_scheduler_is_same_as_func_t = ffi
    .Pointer<ffi.NativeFunction<realm_scheduler_is_same_as_func_tFunction>>;
typedef realm_scheduler_is_same_as_func_tFunction = ffi.Bool Function(
    ffi.Pointer<ffi.Void> scheduler_userdata_1,
    ffi.Pointer<ffi.Void> scheduler_userdata_2);
typedef Dartrealm_scheduler_is_same_as_func_tFunction = bool Function(
    ffi.Pointer<ffi.Void> scheduler_userdata_1,
    ffi.Pointer<ffi.Void> scheduler_userdata_2);

/// Scheduler types
typedef realm_scheduler_notify_func_t
    = ffi.Pointer<ffi.NativeFunction<realm_scheduler_notify_func_tFunction>>;
typedef realm_scheduler_notify_func_tFunction = ffi.Void Function(
    ffi.Pointer<ffi.Void> userdata, ffi.Pointer<realm_work_queue_t> work_queue);
typedef Dartrealm_scheduler_notify_func_tFunction = void Function(
    ffi.Pointer<ffi.Void> userdata, ffi.Pointer<realm_work_queue_t> work_queue);
typedef realm_scheduler_t = realm_scheduler;

final class realm_schema extends ffi.Opaque {}

enum realm_schema_mode {
  RLM_SCHEMA_MODE_AUTOMATIC(0),
  RLM_SCHEMA_MODE_IMMUTABLE(1),
  RLM_SCHEMA_MODE_READ_ONLY(2),
  RLM_SCHEMA_MODE_SOFT_RESET_FILE(3),
  RLM_SCHEMA_MODE_HARD_RESET_FILE(4),
  RLM_SCHEMA_MODE_ADDITIVE_DISCOVERED(5),
  RLM_SCHEMA_MODE_ADDITIVE_EXPLICIT(6),
  RLM_SCHEMA_MODE_MANUAL(7);

  final int value;
  const realm_schema_mode(this.value);

  static realm_schema_mode fromValue(int value) => switch (value) {
        0 => RLM_SCHEMA_MODE_AUTOMATIC,
        1 => RLM_SCHEMA_MODE_IMMUTABLE,
        2 => RLM_SCHEMA_MODE_READ_ONLY,
        3 => RLM_SCHEMA_MODE_SOFT_RESET_FILE,
        4 => RLM_SCHEMA_MODE_HARD_RESET_FILE,
        5 => RLM_SCHEMA_MODE_ADDITIVE_DISCOVERED,
        6 => RLM_SCHEMA_MODE_ADDITIVE_EXPLICIT,
        7 => RLM_SCHEMA_MODE_MANUAL,
        _ => throw ArgumentError("Unknown value for realm_schema_mode: $value"),
      };
}

enum realm_schema_subset_mode {
  RLM_SCHEMA_SUBSET_MODE_STRICT(0),
  RLM_SCHEMA_SUBSET_MODE_ALL_CLASSES(1),
  RLM_SCHEMA_SUBSET_MODE_ALL_PROPERTIES(2),
  RLM_SCHEMA_SUBSET_MODE_COMPLETE(3);

  final int value;
  const realm_schema_subset_mode(this.value);

  static realm_schema_subset_mode fromValue(int value) => switch (value) {
        0 => RLM_SCHEMA_SUBSET_MODE_STRICT,
        1 => RLM_SCHEMA_SUBSET_MODE_ALL_CLASSES,
        2 => RLM_SCHEMA_SUBSET_MODE_ALL_PROPERTIES,
        3 => RLM_SCHEMA_SUBSET_MODE_COMPLETE,
        _ => throw ArgumentError(
            "Unknown value for realm_schema_subset_mode: $value"),
      };
}

typedef realm_schema_t = realm_schema;

enum realm_schema_validation_mode {
  RLM_SCHEMA_VALIDATION_BASIC(0),
  RLM_SCHEMA_VALIDATION_SYNC_PBS(1),
  RLM_SCHEMA_VALIDATION_REJECT_EMBEDDED_ORPHANS(2),
  RLM_SCHEMA_VALIDATION_SYNC_FLX(4);

  final int value;
  const realm_schema_validation_mode(this.value);

  static realm_schema_validation_mode fromValue(int value) => switch (value) {
        0 => RLM_SCHEMA_VALIDATION_BASIC,
        1 => RLM_SCHEMA_VALIDATION_SYNC_PBS,
        2 => RLM_SCHEMA_VALIDATION_REJECT_EMBEDDED_ORPHANS,
        4 => RLM_SCHEMA_VALIDATION_SYNC_FLX,
        _ => throw ArgumentError(
            "Unknown value for realm_schema_validation_mode: $value"),
      };
}

final class realm_set extends ffi.Opaque {}

typedef realm_set_t = realm_set;
typedef realm_should_compact_on_launch_func_t = ffi
    .Pointer<ffi.NativeFunction<realm_should_compact_on_launch_func_tFunction>>;
typedef realm_should_compact_on_launch_func_tFunction = ffi.Bool Function(
    ffi.Pointer<ffi.Void> userdata,
    ffi.Uint64 total_bytes,
    ffi.Uint64 used_bytes);
typedef Dartrealm_should_compact_on_launch_func_tFunction = bool Function(
    ffi.Pointer<ffi.Void> userdata, int total_bytes, int used_bytes);

/// Represents a view over a UTF-8 string buffer. The buffer is unowned by this struct.
///
/// This string can have three states:
/// - null
/// When the data member is NULL.
/// - empty
/// When the data member is non-NULL, and the size member is 0. The actual contents of the data member in this case
/// don't matter.
/// - non-empty
/// When the data member is non-NULL, and the size member is greater than 0.
final class realm_string extends ffi.Struct {
  external ffi.Pointer<ffi.Char> data;

  @ffi.Size()
  external int size;
}

/// Represents a view over a UTF-8 string buffer. The buffer is unowned by this struct.
///
/// This string can have three states:
/// - null
/// When the data member is NULL.
/// - empty
/// When the data member is non-NULL, and the size member is 0. The actual contents of the data member in this case
/// don't matter.
/// - non-empty
/// When the data member is non-NULL, and the size member is greater than 0.
typedef realm_string_t = realm_string;
typedef realm_t = shared_realm;

final class realm_thread_safe_reference extends ffi.Opaque {}

typedef realm_thread_safe_reference_t = realm_thread_safe_reference;

final class realm_timestamp extends ffi.Struct {
  @ffi.Int64()
  external int seconds;

  @ffi.Int32()
  external int nanoseconds;
}

typedef realm_timestamp_t = realm_timestamp;

final class realm_uuid extends ffi.Struct {
  @ffi.Array.multi([16])
  external ffi.Array<ffi.Uint8> bytes;
}

typedef realm_uuid_t = realm_uuid;

final class realm_value extends ffi.Struct {
  external UnnamedUnion1 values;

  @ffi.UnsignedInt()
  external int type;
}

typedef realm_value_t = realm_value;

/// Value types
enum realm_value_type {
  RLM_TYPE_NULL(0),
  RLM_TYPE_INT(1),
  RLM_TYPE_BOOL(2),
  RLM_TYPE_STRING(3),
  RLM_TYPE_BINARY(4),
  RLM_TYPE_TIMESTAMP(5),
  RLM_TYPE_FLOAT(6),
  RLM_TYPE_DOUBLE(7),
  RLM_TYPE_DECIMAL128(8),
  RLM_TYPE_OBJECT_ID(9),
  RLM_TYPE_LINK(10),
  RLM_TYPE_UUID(11),
  RLM_TYPE_LIST(12),
  RLM_TYPE_DICTIONARY(13);

  final int value;
  const realm_value_type(this.value);

  static realm_value_type fromValue(int value) => switch (value) {
        0 => RLM_TYPE_NULL,
        1 => RLM_TYPE_INT,
        2 => RLM_TYPE_BOOL,
        3 => RLM_TYPE_STRING,
        4 => RLM_TYPE_BINARY,
        5 => RLM_TYPE_TIMESTAMP,
        6 => RLM_TYPE_FLOAT,
        7 => RLM_TYPE_DOUBLE,
        8 => RLM_TYPE_DECIMAL128,
        9 => RLM_TYPE_OBJECT_ID,
        10 => RLM_TYPE_LINK,
        11 => RLM_TYPE_UUID,
        12 => RLM_TYPE_LIST,
        13 => RLM_TYPE_DICTIONARY,
        _ => throw ArgumentError("Unknown value for realm_value_type: $value"),
      };
}

final class realm_version_id extends ffi.Struct {
  @ffi.Uint64()
  external int version;

  @ffi.Uint64()
  external int index;
}

typedef realm_version_id_t = realm_version_id;

final class realm_work_queue extends ffi.Opaque {}

typedef realm_work_queue_t = realm_work_queue;

final class shared_realm extends ffi.Opaque {}
